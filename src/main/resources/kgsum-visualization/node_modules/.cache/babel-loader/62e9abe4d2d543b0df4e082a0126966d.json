{"ast":null,"code":"/**\n * @param  {Array<THREE.Material>|THREE.Material} material\n * @return {Array<THREE.Material>}\n */\nfunction ensureMaterialArray(material) {\n  if (!material) {\n    return [];\n  } else if (Array.isArray(material)) {\n    return material;\n  } else if (material.materials) {\n    return material.materials;\n  } else {\n    return [material];\n  }\n}\n/**\n * @param  {THREE.Object3D} mesh\n * @param  {Array<string>} materialNames\n * @param  {THREE.Texture} envMap\n * @param  {number} reflectivity  [description]\n */\n\n\nfunction applyEnvMap(mesh, materialNames, envMap, reflectivity) {\n  if (!mesh) return;\n  materialNames = materialNames || [];\n  mesh.traverse(node => {\n    if (!node.isMesh) return;\n    const meshMaterials = ensureMaterialArray(node.material);\n    meshMaterials.forEach(material => {\n      if (material && !('envMap' in material)) return;\n      if (materialNames.length && materialNames.indexOf(material.name) === -1) return;\n      material.envMap = envMap;\n      material.reflectivity = reflectivity;\n      material.needsUpdate = true;\n    });\n  });\n}\n/**\n * Specifies an envMap on an entity, without replacing any existing material\n * properties.\n */\n\n\nmodule.exports = AFRAME.registerComponent('cube-env-map', {\n  multiple: true,\n  schema: {\n    path: {\n      default: ''\n    },\n    extension: {\n      default: 'jpg',\n      oneOf: ['jpg', 'png']\n    },\n    format: {\n      default: 'RGBFormat',\n      oneOf: ['RGBFormat', 'RGBAFormat']\n    },\n    enableBackground: {\n      default: false\n    },\n    reflectivity: {\n      default: 1,\n      min: 0,\n      max: 1\n    },\n    materials: {\n      default: []\n    }\n  },\n  init: function () {\n    const data = this.data;\n    this.texture = new THREE.CubeTextureLoader().load([data.path + 'posx.' + data.extension, data.path + 'negx.' + data.extension, data.path + 'posy.' + data.extension, data.path + 'negy.' + data.extension, data.path + 'posz.' + data.extension, data.path + 'negz.' + data.extension]);\n    this.texture.format = THREE[data.format];\n\n    this.object3dsetHandler = () => {\n      const mesh = this.el.getObject3D('mesh');\n      const data = this.data;\n      applyEnvMap(mesh, data.materials, this.texture, data.reflectivity);\n    };\n\n    this.el.addEventListener('object3dset', this.object3dsetHandler);\n  },\n  update: function (oldData) {\n    const data = this.data;\n    const mesh = this.el.getObject3D('mesh');\n    let addedMaterialNames = [];\n    let removedMaterialNames = [];\n\n    if (data.materials.length) {\n      if (oldData.materials) {\n        addedMaterialNames = data.materials.filter(name => !oldData.materials.includes(name));\n        removedMaterialNames = oldData.materials.filter(name => !data.materials.includes(name));\n      } else {\n        addedMaterialNames = data.materials;\n      }\n    }\n\n    if (addedMaterialNames.length) {\n      applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);\n    }\n\n    if (removedMaterialNames.length) {\n      applyEnvMap(mesh, removedMaterialNames, null, 1);\n    }\n\n    if (oldData.materials && data.reflectivity !== oldData.reflectivity) {\n      const maintainedMaterialNames = data.materials.filter(name => oldData.materials.includes(name));\n\n      if (maintainedMaterialNames.length) {\n        applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);\n      }\n    }\n\n    if (this.data.enableBackground && !oldData.enableBackground) {\n      this.setBackground(this.texture);\n    } else if (!this.data.enableBackground && oldData.enableBackground) {\n      this.setBackground(null);\n    }\n  },\n  remove: function () {\n    this.el.removeEventListener('object3dset', this.object3dsetHandler);\n    const mesh = this.el.getObject3D('mesh');\n    const data = this.data;\n    applyEnvMap(mesh, data.materials, null, 1);\n    if (data.enableBackground) this.setBackground(null);\n  },\n  setBackground: function (texture) {\n    this.el.sceneEl.object3D.background = texture;\n  }\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/misc/cube-env-map.js"],"names":["ensureMaterialArray","material","Array","isArray","materials","applyEnvMap","mesh","materialNames","envMap","reflectivity","traverse","node","isMesh","meshMaterials","forEach","length","indexOf","name","needsUpdate","module","exports","AFRAME","registerComponent","multiple","schema","path","default","extension","oneOf","format","enableBackground","min","max","init","data","texture","THREE","CubeTextureLoader","load","object3dsetHandler","el","getObject3D","addEventListener","update","oldData","addedMaterialNames","removedMaterialNames","filter","includes","maintainedMaterialNames","setBackground","remove","removeEventListener","sceneEl","object3D","background"],"mappings":"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","sourcesContent":["/**\n * @param  {Array<THREE.Material>|THREE.Material} material\n * @return {Array<THREE.Material>}\n */\nfunction ensureMaterialArray (material) {\n  if (!material) {\n    return [];\n  } else if (Array.isArray(material)) {\n    return material;\n  } else if (material.materials) {\n    return material.materials;\n  } else {\n    return [material];\n  }\n}\n\n/**\n * @param  {THREE.Object3D} mesh\n * @param  {Array<string>} materialNames\n * @param  {THREE.Texture} envMap\n * @param  {number} reflectivity  [description]\n */\nfunction applyEnvMap (mesh, materialNames, envMap, reflectivity) {\n  if (!mesh) return;\n\n  materialNames = materialNames || [];\n\n  mesh.traverse((node) => {\n\n    if (!node.isMesh) return;\n\n    const meshMaterials = ensureMaterialArray(node.material);\n\n    meshMaterials.forEach((material) => {\n\n      if (material && !('envMap' in material)) return;\n      if (materialNames.length && materialNames.indexOf(material.name) === -1) return;\n\n      material.envMap = envMap;\n      material.reflectivity = reflectivity;\n      material.needsUpdate = true;\n\n    });\n\n  });\n}\n\n/**\n * Specifies an envMap on an entity, without replacing any existing material\n * properties.\n */\nmodule.exports = AFRAME.registerComponent('cube-env-map', {\n  multiple: true,\n\n  schema: {\n    path: {default: ''},\n    extension: {default: 'jpg', oneOf: ['jpg', 'png']},\n    format: {default: 'RGBFormat', oneOf: ['RGBFormat', 'RGBAFormat']},\n    enableBackground: {default: false},\n    reflectivity: {default: 1, min: 0, max: 1},\n    materials: {default: []}\n  },\n\n  init: function () {\n    const data = this.data;\n\n    this.texture = new THREE.CubeTextureLoader().load([\n      data.path + 'posx.' + data.extension, data.path + 'negx.' + data.extension,\n      data.path + 'posy.' + data.extension, data.path + 'negy.' + data.extension,\n      data.path + 'posz.' + data.extension, data.path + 'negz.' + data.extension\n    ]);\n    this.texture.format = THREE[data.format];\n\n    this.object3dsetHandler = () => {\n      const mesh = this.el.getObject3D('mesh');\n      const data = this.data;\n      applyEnvMap(mesh, data.materials, this.texture, data.reflectivity);\n    };\n    this.el.addEventListener('object3dset', this.object3dsetHandler);\n  },\n\n  update: function (oldData) {\n    const data = this.data;\n    const mesh = this.el.getObject3D('mesh');\n\n    let addedMaterialNames = [];\n    let removedMaterialNames = [];\n\n    if (data.materials.length) {\n      if (oldData.materials) {\n        addedMaterialNames = data.materials.filter((name) => !oldData.materials.includes(name));\n        removedMaterialNames = oldData.materials.filter((name) => !data.materials.includes(name));\n      } else {\n        addedMaterialNames = data.materials;\n      }\n    }\n    if (addedMaterialNames.length) {\n      applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);\n    }\n    if (removedMaterialNames.length) {\n      applyEnvMap(mesh, removedMaterialNames, null, 1);\n    }\n\n    if (oldData.materials && data.reflectivity !== oldData.reflectivity) {\n      const maintainedMaterialNames = data.materials\n        .filter((name) => oldData.materials.includes(name));\n      if (maintainedMaterialNames.length) {\n        applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);\n      }\n    }\n\n    if (this.data.enableBackground && !oldData.enableBackground) {\n      this.setBackground(this.texture);\n    } else if (!this.data.enableBackground && oldData.enableBackground) {\n      this.setBackground(null);\n    }\n  },\n\n  remove: function () {\n    this.el.removeEventListener('object3dset', this.object3dsetHandler);\n    const mesh = this.el.getObject3D('mesh');\n    const data = this.data;\n\n    applyEnvMap(mesh, data.materials, null, 1);\n    if (data.enableBackground) this.setBackground(null);\n  },\n\n  setBackground: function (texture) {\n    this.el.sceneEl.object3D.background = texture;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}