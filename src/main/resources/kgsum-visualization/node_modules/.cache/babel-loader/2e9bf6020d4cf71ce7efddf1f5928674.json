{"ast":null,"code":"const EPS = 0.1;\nmodule.exports = AFRAME.registerComponent('checkpoint-controls', {\n  schema: {\n    enabled: {\n      default: true\n    },\n    mode: {\n      default: 'teleport',\n      oneOf: ['teleport', 'animate']\n    },\n    animateSpeed: {\n      default: 3.0\n    }\n  },\n  init: function () {\n    this.active = true;\n    this.checkpoint = null;\n    this.isNavMeshConstrained = false;\n    this.offset = new THREE.Vector3();\n    this.position = new THREE.Vector3();\n    this.targetPosition = new THREE.Vector3();\n  },\n  play: function () {\n    this.active = true;\n  },\n  pause: function () {\n    this.active = false;\n  },\n  setCheckpoint: function (checkpoint) {\n    const el = this.el;\n    if (!this.active) return;\n    if (this.checkpoint === checkpoint) return;\n\n    if (this.checkpoint) {\n      el.emit('navigation-end', {\n        checkpoint: this.checkpoint\n      });\n    }\n\n    this.checkpoint = checkpoint;\n    this.sync(); // Ignore new checkpoint if we're already there.\n\n    if (this.position.distanceTo(this.targetPosition) < EPS) {\n      this.checkpoint = null;\n      return;\n    }\n\n    el.emit('navigation-start', {\n      checkpoint: checkpoint\n    });\n\n    if (this.data.mode === 'teleport') {\n      this.el.setAttribute('position', this.targetPosition);\n      this.checkpoint = null;\n      el.emit('navigation-end', {\n        checkpoint: checkpoint\n      });\n      el.components['movement-controls'].updateNavLocation();\n    }\n  },\n  isVelocityActive: function () {\n    return !!(this.active && this.checkpoint);\n  },\n  getVelocity: function () {\n    if (!this.active) return;\n    const data = this.data;\n    const offset = this.offset;\n    const position = this.position;\n    const targetPosition = this.targetPosition;\n    const checkpoint = this.checkpoint;\n    this.sync();\n\n    if (position.distanceTo(targetPosition) < EPS) {\n      this.checkpoint = null;\n      this.el.emit('navigation-end', {\n        checkpoint: checkpoint\n      });\n      return offset.set(0, 0, 0);\n    }\n\n    offset.setLength(data.animateSpeed);\n    return offset;\n  },\n  sync: function () {\n    const offset = this.offset;\n    const position = this.position;\n    const targetPosition = this.targetPosition;\n    position.copy(this.el.getAttribute('position'));\n    this.checkpoint.object3D.getWorldPosition(targetPosition);\n    targetPosition.add(this.checkpoint.components.checkpoint.getOffset());\n    offset.copy(targetPosition).sub(position);\n  }\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/controls/checkpoint-controls.js"],"names":["EPS","module","exports","AFRAME","registerComponent","schema","enabled","default","mode","oneOf","animateSpeed","init","active","checkpoint","isNavMeshConstrained","offset","THREE","Vector3","position","targetPosition","play","pause","setCheckpoint","el","emit","sync","distanceTo","data","setAttribute","components","updateNavLocation","isVelocityActive","getVelocity","set","setLength","copy","getAttribute","object3D","getWorldPosition","add","getOffset","sub"],"mappings":"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","sourcesContent":["const EPS = 0.1;\n\nmodule.exports = AFRAME.registerComponent('checkpoint-controls', {\n  schema: {\n    enabled: {default: true},\n    mode: {default: 'teleport', oneOf: ['teleport', 'animate']},\n    animateSpeed: {default: 3.0}\n  },\n\n  init: function () {\n    this.active = true;\n    this.checkpoint = null;\n\n    this.isNavMeshConstrained = false;\n\n    this.offset = new THREE.Vector3();\n    this.position = new THREE.Vector3();\n    this.targetPosition = new THREE.Vector3();\n  },\n\n  play: function () { this.active = true; },\n  pause: function () { this.active = false; },\n\n  setCheckpoint: function (checkpoint) {\n    const el = this.el;\n\n    if (!this.active) return;\n    if (this.checkpoint === checkpoint) return;\n\n    if (this.checkpoint) {\n      el.emit('navigation-end', {checkpoint: this.checkpoint});\n    }\n\n    this.checkpoint = checkpoint;\n    this.sync();\n\n    // Ignore new checkpoint if we're already there.\n    if (this.position.distanceTo(this.targetPosition) < EPS) {\n      this.checkpoint = null;\n      return;\n    }\n\n    el.emit('navigation-start', {checkpoint: checkpoint});\n\n    if (this.data.mode === 'teleport') {\n      this.el.setAttribute('position', this.targetPosition);\n      this.checkpoint = null;\n      el.emit('navigation-end', {checkpoint: checkpoint});\n      el.components['movement-controls'].updateNavLocation();\n    }\n  },\n\n  isVelocityActive: function () {\n    return !!(this.active && this.checkpoint);\n  },\n\n  getVelocity: function () {\n    if (!this.active) return;\n\n    const data = this.data;\n    const offset = this.offset;\n    const position = this.position;\n    const targetPosition = this.targetPosition;\n    const checkpoint = this.checkpoint;\n\n    this.sync();\n    if (position.distanceTo(targetPosition) < EPS) {\n      this.checkpoint = null;\n      this.el.emit('navigation-end', {checkpoint: checkpoint});\n      return offset.set(0, 0, 0);\n    }\n    offset.setLength(data.animateSpeed);\n    return offset;\n  },\n\n  sync: function () {\n    const offset = this.offset;\n    const position = this.position;\n    const targetPosition = this.targetPosition;\n\n    position.copy(this.el.getAttribute('position'));\n    this.checkpoint.object3D.getWorldPosition(targetPosition);\n    targetPosition.add(this.checkpoint.components.checkpoint.getOffset());\n    offset.copy(targetPosition).sub(position);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}