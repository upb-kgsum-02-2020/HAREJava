{"ast":null,"code":"/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nconst EPS = 0.000001;\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n  schema: {\n    mass: {\n      default: 5\n    },\n    radius: {\n      default: 1.3\n    },\n    linearDamping: {\n      default: 0.05\n    },\n    enableSlopes: {\n      default: true\n    },\n    enableJumps: {\n      default: false\n    }\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n    const el = this.el,\n          data = this.data,\n          position = new CANNON.Vec3().copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(new CANNON.Sphere(data.radius), new CANNON.Vec3(0, data.radius, 0));\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n  remove: function () {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function (t, dt) {\n    if (!dt) return;\n    const el = this.el;\n    const data = this.data;\n    const body = this.body;\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n  step: function () {\n    const velocity = new THREE.Vector3(),\n          normalizedVelocity = new THREE.Vector3(),\n          currentSurfaceNormal = new THREE.Vector3(),\n          groundNormal = new THREE.Vector3();\n    return function (t, dt) {\n      if (!dt) return;\n      let body = this.body,\n          data = this.data,\n          didCollide = false,\n          height,\n          groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) {\n          continue;\n        }\n\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id ? Math.abs(contact.rj.y + contact.bj.position.y) : Math.abs(contact.ri.y + contact.bi.position.y);\n\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        } // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n\n\n        velocity.projectOnPlane(groundNormal);\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }(),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function (groundBody, groundNormal) {\n    let ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n    ray = new CANNON.Ray(vFrom, vTo);\n\n    ray._updateDirection(); // TODO - Report bug.\n\n\n    ray.intersectBody(groundBody);\n    if (!ray.hasHit) return groundNormal; // Compare ABS, in case we're projecting against the inside of the face.\n\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/misc/kinematic-body.js"],"names":["EPS","module","exports","AFRAME","registerComponent","dependencies","schema","mass","default","radius","linearDamping","enableSlopes","enableJumps","init","system","el","sceneEl","systems","physics","addComponent","data","position","CANNON","Vec3","copy","object3D","getWorldPosition","THREE","Vector3","body","Body","material","getMaterial","fixedRotation","addShape","Sphere","addBody","hasAttribute","console","warn","remove","removeBody","removeComponent","beforeStep","t","dt","velocity","set","getAttribute","step","normalizedVelocity","currentSurfaceNormal","groundNormal","didCollide","height","groundHeight","Infinity","groundBody","contacts","getContacts","Math","min","maxInterval","i","contact","enabled","id","bi","ni","negate","bj","dot","y","projectOnPlane","abs","rj","ri","normalize","raycastToGround","driver","world","add","gravity","scale","setAttribute","ray","hitNormal","vFrom","vTo","clone","Ray","_updateDirection","intersectBody","hasHit","result","hitNormalWorld"],"mappings":"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","sourcesContent":["/* global CANNON */\n\n/**\n * Kinematic body.\n *\n * Managed dynamic body, which moves but is not affected (directly) by the\n * physics engine. This is not a true kinematic body, in the sense that we are\n * letting the physics engine _compute_ collisions against it and selectively\n * applying those collisions to the object. The physics engine does not decide\n * the position/velocity/rotation of the element.\n *\n * Used for the camera object, because full physics simulation would create\n * movement that feels unnatural to the player. Bipedal movement does not\n * translate nicely to rigid body physics.\n *\n * See: http://www.learn-cocos2d.com/2013/08/physics-engine-platformer-terrible-idea/\n * And: http://oxleygamedev.blogspot.com/2011/04/player-physics-part-2.html\n */\nconst EPS = 0.000001;\n\nmodule.exports = AFRAME.registerComponent('kinematic-body', {\n  dependencies: ['velocity'],\n\n  /*******************************************************************\n   * Schema\n   */\n\n  schema: {\n    mass:           { default: 5 },\n    radius:         { default: 1.3 },\n    linearDamping:  { default: 0.05 },\n    enableSlopes:   { default: true },\n    enableJumps:    { default: false },\n  },\n\n  /*******************************************************************\n   * Lifecycle\n   */\n\n  init: function () {\n    this.system = this.el.sceneEl.systems.physics;\n    this.system.addComponent(this);\n\n    const el = this.el,\n        data = this.data,\n        position = (new CANNON.Vec3()).copy(el.object3D.getWorldPosition(new THREE.Vector3()));\n\n    this.body = new CANNON.Body({\n      material: this.system.getMaterial('staticMaterial'),\n      position: position,\n      mass: data.mass,\n      linearDamping: data.linearDamping,\n      fixedRotation: true\n    });\n    this.body.addShape(\n      new CANNON.Sphere(data.radius),\n      new CANNON.Vec3(0, data.radius, 0)\n    );\n\n    this.body.el = this.el;\n    this.el.body = this.body;\n    this.system.addBody(this.body);\n\n    if (el.hasAttribute('wasd-controls')) {\n      console.warn('[kinematic-body] Not compatible with wasd-controls, use movement-controls.');\n    }\n  },\n\n  remove: function () {\n    this.system.removeBody(this.body);\n    this.system.removeComponent(this);\n    delete this.el.body;\n  },\n\n  /*******************************************************************\n   * Update\n   */\n\n  /**\n   * Checks CANNON.World for collisions and attempts to apply them to the\n   * element automatically, in a player-friendly way.\n   *\n   * There's extra logic for horizontal surfaces here. The basic requirements:\n   * (1) Only apply gravity when not in contact with _any_ horizontal surface.\n   * (2) When moving, project the velocity against exactly one ground surface.\n   *     If in contact with two ground surfaces (e.g. ground + ramp), choose\n   *     the one that collides with current velocity, if any.\n   */\n  beforeStep: function (t, dt) {\n    if (!dt) return;\n\n    const el = this.el;\n    const data = this.data\n    const body = this.body;\n\n    if (!data.enableJumps) body.velocity.set(0, 0, 0);\n    body.position.copy(el.getAttribute('position'));\n  },\n\n  step: (function () {\n    const velocity = new THREE.Vector3(),\n        normalizedVelocity = new THREE.Vector3(),\n        currentSurfaceNormal = new THREE.Vector3(),\n        groundNormal = new THREE.Vector3();\n\n    return function (t, dt) {\n      if (!dt) return;\n\n      let body = this.body,\n          data = this.data,\n          didCollide = false,\n          height, groundHeight = -Infinity,\n          groundBody,\n          contacts = this.system.getContacts();\n\n      dt = Math.min(dt, this.system.data.maxInterval * 1000);\n\n      groundNormal.set(0, 0, 0);\n      velocity.copy(this.el.getAttribute('velocity'));\n      body.velocity.copy(velocity);\n\n      for (var i = 0, contact; contact = contacts[i]; i++) {\n        // 1. Find any collisions involving this element. Get the contact\n        // normal, and make sure it's oriented _out_ of the other object and\n        // enabled (body.collisionReponse is true for both bodies)\n        if (!contact.enabled) { continue; }\n        if (body.id === contact.bi.id) {\n          contact.ni.negate(currentSurfaceNormal);\n        } else if (body.id === contact.bj.id) {\n          currentSurfaceNormal.copy(contact.ni);\n        } else {\n          continue;\n        }\n\n        didCollide = body.velocity.dot(currentSurfaceNormal) < -EPS;\n        if (didCollide && currentSurfaceNormal.y <= 0.5) {\n          // 2. If current trajectory attempts to move _through_ another\n          // object, project the velocity against the collision plane to\n          // prevent passing through.\n          velocity.projectOnPlane(currentSurfaceNormal);\n        } else if (currentSurfaceNormal.y > 0.5) {\n          // 3. If in contact with something roughly horizontal (+/- 45ยบ) then\n          // consider that the current ground. Only the highest qualifying\n          // ground is retained.\n          height = body.id === contact.bi.id\n            ? Math.abs(contact.rj.y + contact.bj.position.y)\n            : Math.abs(contact.ri.y + contact.bi.position.y);\n          if (height > groundHeight) {\n            groundHeight = height;\n            groundNormal.copy(currentSurfaceNormal);\n            groundBody = body.id === contact.bi.id ? contact.bj : contact.bi;\n          }\n        }\n      }\n\n      normalizedVelocity.copy(velocity).normalize();\n      if (groundBody && (!data.enableJumps || normalizedVelocity.y < 0.5)) {\n        if (!data.enableSlopes) {\n          groundNormal.set(0, 1, 0);\n        } else if (groundNormal.y < 1 - EPS) {\n          groundNormal.copy(this.raycastToGround(groundBody, groundNormal));\n        }\n\n        // 4. Project trajectory onto the top-most ground object, unless\n        // trajectory is > 45ยบ.\n        velocity.projectOnPlane(groundNormal);\n\n      } else if (this.system.driver.world) {\n        // 5. If not in contact with anything horizontal, apply world gravity.\n        // TODO - Why is the 4x scalar necessary.\n        // NOTE: Does not work if physics runs on a worker.\n        velocity.add(this.system.driver.world.gravity.scale(dt * 4.0 / 1000));\n      }\n\n      body.velocity.copy(velocity);\n      this.el.setAttribute('velocity', body.velocity);\n      this.el.setAttribute('position', body.position);\n    };\n  }()),\n\n  /**\n   * When walking on complex surfaces (trimeshes, borders between two shapes),\n   * the collision normals returned for the player sphere can be very\n   * inconsistent. To address this, raycast straight down, find the collision\n   * normal, and return whichever normal is more vertical.\n   * @param  {CANNON.Body} groundBody\n   * @param  {CANNON.Vec3} groundNormal\n   * @return {CANNON.Vec3}\n   */\n  raycastToGround: function (groundBody, groundNormal) {\n    let ray,\n        hitNormal,\n        vFrom = this.body.position,\n        vTo = this.body.position.clone();\n\n    ray = new CANNON.Ray(vFrom, vTo);\n    ray._updateDirection(); // TODO - Report bug.\n    ray.intersectBody(groundBody);\n\n    if (!ray.hasHit) return groundNormal;\n\n    // Compare ABS, in case we're projecting against the inside of the face.\n    hitNormal = ray.result.hitNormalWorld;\n    return Math.abs(hitNormal.y) > Math.abs(groundNormal.y) ? hitNormal : groundNormal;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}