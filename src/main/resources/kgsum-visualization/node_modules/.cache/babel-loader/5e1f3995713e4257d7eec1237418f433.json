{"ast":null,"code":"const {\n  Pathfinding\n} = require('three-pathfinding');\n\nconst pathfinder = new Pathfinding();\nconst ZONE = 'level';\n/**\n * nav\n *\n * Pathfinding system, using PatrolJS.\n */\n\nmodule.exports = AFRAME.registerSystem('nav', {\n  init: function () {\n    this.navMesh = null;\n    this.agents = new Set();\n  },\n\n  /**\n   * @param {THREE.Geometry} geometry\n   */\n  setNavMeshGeometry: function (geometry) {\n    this.navMesh = new THREE.Mesh(geometry);\n    pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));\n    Array.from(this.agents).forEach(agent => agent.updateNavLocation());\n  },\n\n  /**\n   * @return {THREE.Mesh}\n   */\n  getNavMesh: function () {\n    return this.navMesh;\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  addAgent: function (ctrl) {\n    this.agents.add(ctrl);\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  removeAgent: function (ctrl) {\n    this.agents.delete(ctrl);\n  },\n\n  /**\n   * @param  {THREE.Vector3} start\n   * @param  {THREE.Vector3} end\n   * @param  {number} groupID\n   * @return {Array<THREE.Vector3>}\n   */\n  getPath: function (start, end, groupID) {\n    return this.navMesh ? pathfinder.findPath(start, end, ZONE, groupID) : null;\n  },\n\n  /**\n   * @param {THREE.Vector3} position\n   * @return {number}\n   */\n  getGroup: function (position) {\n    return this.navMesh ? pathfinder.getGroup(ZONE, position) : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} position\n   * @param  {number} groupID\n   * @return {Node}\n   */\n  getNode: function (position, groupID) {\n    return this.navMesh ? pathfinder.getClosestNode(position, ZONE, groupID, true) : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} start Starting position.\n   * @param  {THREE.Vector3} end Desired ending position.\n   * @param  {number} groupID\n   * @param  {Node} node\n   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.\n   * @return {Node} Current node, after step is taken.\n   */\n  clampStep: function (start, end, groupID, node, endTarget) {\n    if (!this.navMesh) {\n      endTarget.copy(end);\n      return null;\n    } else if (!node) {\n      endTarget.copy(end);\n      return this.getNode(end, groupID);\n    }\n\n    return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);\n  }\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/kgsum/kgsum-visualization/node_modules/aframe-extras/src/pathfinding/system.js"],"names":["Pathfinding","require","pathfinder","ZONE","module","exports","AFRAME","registerSystem","init","navMesh","agents","Set","setNavMeshGeometry","geometry","THREE","Mesh","setZoneData","createZone","Array","from","forEach","agent","updateNavLocation","getNavMesh","addAgent","ctrl","add","removeAgent","delete","getPath","start","end","groupID","findPath","getGroup","position","getNode","getClosestNode","clampStep","node","endTarget","copy"],"mappings":"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","sourcesContent":["const { Pathfinding } = require('three-pathfinding');\n\nconst pathfinder = new Pathfinding();\nconst ZONE = 'level';\n\n/**\n * nav\n *\n * Pathfinding system, using PatrolJS.\n */\nmodule.exports = AFRAME.registerSystem('nav', {\n  init: function () {\n    this.navMesh = null;\n    this.agents = new Set();\n  },\n\n  /**\n   * @param {THREE.Geometry} geometry\n   */\n  setNavMeshGeometry: function (geometry) {\n    this.navMesh = new THREE.Mesh(geometry);\n    pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));\n    Array.from(this.agents).forEach((agent) => agent.updateNavLocation());\n  },\n\n  /**\n   * @return {THREE.Mesh}\n   */\n  getNavMesh: function () {\n    return this.navMesh;\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  addAgent: function (ctrl) {\n    this.agents.add(ctrl);\n  },\n\n  /**\n   * @param {NavAgent} ctrl\n   */\n  removeAgent: function (ctrl) {\n    this.agents.delete(ctrl);\n  },\n\n  /**\n   * @param  {THREE.Vector3} start\n   * @param  {THREE.Vector3} end\n   * @param  {number} groupID\n   * @return {Array<THREE.Vector3>}\n   */\n  getPath: function (start, end, groupID) {\n    return this.navMesh\n      ? pathfinder.findPath(start, end, ZONE, groupID)\n      : null;\n  },\n\n  /**\n   * @param {THREE.Vector3} position\n   * @return {number}\n   */\n  getGroup: function (position) {\n    return this.navMesh\n      ? pathfinder.getGroup(ZONE, position)\n      : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} position\n   * @param  {number} groupID\n   * @return {Node}\n   */\n  getNode: function (position, groupID) {\n    return this.navMesh\n      ? pathfinder.getClosestNode(position, ZONE, groupID, true)\n      : null;\n  },\n\n  /**\n   * @param  {THREE.Vector3} start Starting position.\n   * @param  {THREE.Vector3} end Desired ending position.\n   * @param  {number} groupID\n   * @param  {Node} node\n   * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.\n   * @return {Node} Current node, after step is taken.\n   */\n  clampStep: function (start, end, groupID, node, endTarget) {\n    if (!this.navMesh) {\n      endTarget.copy(end);\n      return null;\n    } else if (!node) {\n      endTarget.copy(end);\n      return this.getNode(end, groupID);\n    }\n    return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}