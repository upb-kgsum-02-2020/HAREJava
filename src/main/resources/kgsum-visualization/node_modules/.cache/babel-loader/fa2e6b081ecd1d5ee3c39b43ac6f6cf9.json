{"ast":null,"code":"/**\n * nav-mesh\n *\n * Waits for a mesh to be loaded on the current entity, then sets it as the\n * nav mesh in the pathfinding system.\n */\nmodule.exports = AFRAME.registerComponent('nav-mesh', {\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.hasLoadedNavMesh = false;\n    this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));\n  },\n  play: function () {\n    if (!this.hasLoadedNavMesh) this.loadNavMesh();\n  },\n  loadNavMesh: function () {\n    const object = this.el.getObject3D('mesh');\n    const scene = this.el.sceneEl.object3D;\n    if (!object) return;\n    let navMesh;\n    object.traverse(node => {\n      if (node.isMesh) navMesh = node;\n    });\n    if (!navMesh) return;\n    const navMeshGeometry = navMesh.geometry.isBufferGeometry ? new THREE.Geometry().fromBufferGeometry(navMesh.geometry) : navMesh.geometry.clone();\n    scene.updateMatrixWorld();\n    navMeshGeometry.applyMatrix(navMesh.matrixWorld);\n    this.system.setNavMeshGeometry(navMeshGeometry);\n    this.hasLoadedNavMesh = true;\n  }\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/pathfinding/nav-mesh.js"],"names":["module","exports","AFRAME","registerComponent","init","system","el","sceneEl","systems","nav","hasLoadedNavMesh","addEventListener","loadNavMesh","bind","play","object","getObject3D","scene","object3D","navMesh","traverse","node","isMesh","navMeshGeometry","geometry","isBufferGeometry","THREE","Geometry","fromBufferGeometry","clone","updateMatrixWorld","applyMatrix","matrixWorld","setNavMeshGeometry"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAP,GAAiBC,MAAM,CAACC,iBAAP,CAAyB,UAAzB,EAAqC;AACpDC,EAAAA,IAAI,EAAE,YAAY;AAChB,SAAKC,MAAL,GAAc,KAAKC,EAAL,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,GAAtC;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AACA,SAAKJ,EAAL,CAAQK,gBAAR,CAAyB,aAAzB,EAAwC,KAAKC,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAxC;AACD,GALmD;AAOpDC,EAAAA,IAAI,EAAE,YAAY;AAChB,QAAI,CAAC,KAAKJ,gBAAV,EAA4B,KAAKE,WAAL;AAC7B,GATmD;AAWpDA,EAAAA,WAAW,EAAE,YAAY;AACvB,UAAMG,MAAM,GAAG,KAAKT,EAAL,CAAQU,WAAR,CAAoB,MAApB,CAAf;AACA,UAAMC,KAAK,GAAG,KAAKX,EAAL,CAAQC,OAAR,CAAgBW,QAA9B;AAEA,QAAI,CAACH,MAAL,EAAa;AAEb,QAAII,OAAJ;AACAJ,IAAAA,MAAM,CAACK,QAAP,CAAiBC,IAAD,IAAU;AACxB,UAAIA,IAAI,CAACC,MAAT,EAAiBH,OAAO,GAAGE,IAAV;AAClB,KAFD;AAIA,QAAI,CAACF,OAAL,EAAc;AAEd,UAAMI,eAAe,GAAGJ,OAAO,CAACK,QAAR,CAAiBC,gBAAjB,GACpB,IAAIC,KAAK,CAACC,QAAV,GAAqBC,kBAArB,CAAwCT,OAAO,CAACK,QAAhD,CADoB,GAEpBL,OAAO,CAACK,QAAR,CAAiBK,KAAjB,EAFJ;AAIAZ,IAAAA,KAAK,CAACa,iBAAN;AACAP,IAAAA,eAAe,CAACQ,WAAhB,CAA4BZ,OAAO,CAACa,WAApC;AACA,SAAK3B,MAAL,CAAY4B,kBAAZ,CAA+BV,eAA/B;AAEA,SAAKb,gBAAL,GAAwB,IAAxB;AACD;AAjCmD,CAArC,CAAjB","sourcesContent":["/**\n * nav-mesh\n *\n * Waits for a mesh to be loaded on the current entity, then sets it as the\n * nav mesh in the pathfinding system.\n */\nmodule.exports = AFRAME.registerComponent('nav-mesh', {\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.hasLoadedNavMesh = false;\n    this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));\n  },\n\n  play: function () {\n    if (!this.hasLoadedNavMesh) this.loadNavMesh();\n  },\n\n  loadNavMesh: function () {\n    const object = this.el.getObject3D('mesh');\n    const scene = this.el.sceneEl.object3D;\n\n    if (!object) return;\n\n    let navMesh;\n    object.traverse((node) => {\n      if (node.isMesh) navMesh = node;\n    });\n\n    if (!navMesh) return;\n\n    const navMeshGeometry = navMesh.geometry.isBufferGeometry\n      ? new THREE.Geometry().fromBufferGeometry(navMesh.geometry)\n      : navMesh.geometry.clone();\n\n    scene.updateMatrixWorld();\n    navMeshGeometry.applyMatrix(navMesh.matrixWorld);\n    this.system.setNavMeshGeometry(navMeshGeometry);\n\n    this.hasLoadedNavMesh = true;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}