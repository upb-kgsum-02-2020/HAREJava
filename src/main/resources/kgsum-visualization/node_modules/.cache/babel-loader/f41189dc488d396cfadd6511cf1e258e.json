{"ast":null,"code":"const LoopMode = {\n  once: THREE.LoopOnce,\n  repeat: THREE.LoopRepeat,\n  pingpong: THREE.LoopPingPong\n};\n/**\n * animation-mixer\n *\n * Player for animation clips. Intended to be compatible with any model format that supports\n * skeletal or morph animations through THREE.AnimationMixer.\n * See: https://threejs.org/docs/?q=animation#Reference/Animation/AnimationMixer\n */\n\nmodule.exports = AFRAME.registerComponent('animation-mixer', {\n  schema: {\n    clip: {\n      default: '*'\n    },\n    duration: {\n      default: 0\n    },\n    clampWhenFinished: {\n      default: false,\n      type: 'boolean'\n    },\n    crossFadeDuration: {\n      default: 0\n    },\n    loop: {\n      default: 'repeat',\n      oneOf: Object.keys(LoopMode)\n    },\n    repetitions: {\n      default: Infinity,\n      min: 0\n    },\n    timeScale: {\n      default: 1\n    }\n  },\n  init: function () {\n    /** @type {THREE.Mesh} */\n    this.model = null;\n    /** @type {THREE.AnimationMixer} */\n\n    this.mixer = null;\n    /** @type {Array<THREE.AnimationAction>} */\n\n    this.activeActions = [];\n    const model = this.el.getObject3D('mesh');\n\n    if (model) {\n      this.load(model);\n    } else {\n      this.el.addEventListener('model-loaded', e => {\n        this.load(e.detail.model);\n      });\n    }\n  },\n  load: function (model) {\n    const el = this.el;\n    this.model = model;\n    this.mixer = new THREE.AnimationMixer(model);\n    this.mixer.addEventListener('loop', e => {\n      el.emit('animation-loop', {\n        action: e.action,\n        loopDelta: e.loopDelta\n      });\n    });\n    this.mixer.addEventListener('finished', e => {\n      el.emit('animation-finished', {\n        action: e.action,\n        direction: e.direction\n      });\n    });\n    if (this.data.clip) this.update({});\n  },\n  remove: function () {\n    if (this.mixer) this.mixer.stopAllAction();\n  },\n  update: function (prevData) {\n    if (!prevData) return;\n    const data = this.data;\n    const changes = AFRAME.utils.diff(data, prevData); // If selected clips have changed, restart animation.\n\n    if ('clip' in changes) {\n      this.stopAction();\n      if (data.clip) this.playAction();\n      return;\n    } // Otherwise, modify running actions.\n\n\n    this.activeActions.forEach(action => {\n      if ('duration' in changes && data.duration) {\n        action.setDuration(data.duration);\n      }\n\n      if ('clampWhenFinished' in changes) {\n        action.clampWhenFinished = data.clampWhenFinished;\n      }\n\n      if ('loop' in changes || 'repetitions' in changes) {\n        action.setLoop(LoopMode[data.loop], data.repetitions);\n      }\n\n      if ('timeScale' in changes) {\n        action.setEffectiveTimeScale(data.timeScale);\n      }\n    });\n  },\n  stopAction: function () {\n    const data = this.data;\n\n    for (let i = 0; i < this.activeActions.length; i++) {\n      data.crossFadeDuration ? this.activeActions[i].fadeOut(data.crossFadeDuration) : this.activeActions[i].stop();\n    }\n\n    this.activeActions.length = 0;\n  },\n  playAction: function () {\n    if (!this.mixer) return;\n    const model = this.model,\n          data = this.data,\n          clips = model.animations || (model.geometry || {}).animations || [];\n    if (!clips.length) return;\n    const re = wildcardToRegExp(data.clip);\n\n    for (let clip, i = 0; clip = clips[i]; i++) {\n      if (clip.name.match(re)) {\n        const action = this.mixer.clipAction(clip, model);\n        action.enabled = true;\n        action.clampWhenFinished = data.clampWhenFinished;\n        if (data.duration) action.setDuration(data.duration);\n        if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);\n        action.setLoop(LoopMode[data.loop], data.repetitions).fadeIn(data.crossFadeDuration).play();\n        this.activeActions.push(action);\n      }\n    }\n  },\n  tick: function (t, dt) {\n    if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1000);\n  }\n});\n/**\n * Creates a RegExp from the given string, converting asterisks to .* expressions,\n * and escaping all other characters.\n */\n\nfunction wildcardToRegExp(s) {\n  return new RegExp('^' + s.split(/\\*+/).map(regExpEscape).join('.*') + '$');\n}\n/**\n * RegExp-escapes all characters in the given string.\n */\n\n\nfunction regExpEscape(s) {\n  return s.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n}","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/loaders/animation-mixer.js"],"names":["LoopMode","once","THREE","LoopOnce","repeat","LoopRepeat","pingpong","LoopPingPong","module","exports","AFRAME","registerComponent","schema","clip","default","duration","clampWhenFinished","type","crossFadeDuration","loop","oneOf","Object","keys","repetitions","Infinity","min","timeScale","init","model","mixer","activeActions","el","getObject3D","load","addEventListener","e","detail","AnimationMixer","emit","action","loopDelta","direction","data","update","remove","stopAllAction","prevData","changes","utils","diff","stopAction","playAction","forEach","setDuration","setLoop","setEffectiveTimeScale","i","length","fadeOut","stop","clips","animations","geometry","re","wildcardToRegExp","name","match","clipAction","enabled","fadeIn","play","push","tick","t","dt","isNaN","s","RegExp","split","map","regExpEscape","join","replace"],"mappings":"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","sourcesContent":["const LoopMode = {\n  once: THREE.LoopOnce,\n  repeat: THREE.LoopRepeat,\n  pingpong: THREE.LoopPingPong\n};\n\n/**\n * animation-mixer\n *\n * Player for animation clips. Intended to be compatible with any model format that supports\n * skeletal or morph animations through THREE.AnimationMixer.\n * See: https://threejs.org/docs/?q=animation#Reference/Animation/AnimationMixer\n */\nmodule.exports = AFRAME.registerComponent('animation-mixer', {\n  schema: {\n    clip:  {default: '*'},\n    duration: {default: 0},\n    clampWhenFinished: {default: false, type: 'boolean'},\n    crossFadeDuration: {default: 0},\n    loop: {default: 'repeat', oneOf: Object.keys(LoopMode)},\n    repetitions: {default: Infinity, min: 0},\n    timeScale: {default: 1}\n  },\n\n  init: function () {\n    /** @type {THREE.Mesh} */\n    this.model = null;\n    /** @type {THREE.AnimationMixer} */\n    this.mixer = null;\n    /** @type {Array<THREE.AnimationAction>} */\n    this.activeActions = [];\n\n    const model = this.el.getObject3D('mesh');\n\n    if (model) {\n      this.load(model);\n    } else {\n      this.el.addEventListener('model-loaded', (e) => {\n        this.load(e.detail.model);\n      });\n    }\n  },\n\n  load: function (model) {\n    const el = this.el;\n    this.model = model;\n    this.mixer = new THREE.AnimationMixer(model);\n    this.mixer.addEventListener('loop', (e) => {\n      el.emit('animation-loop', {action: e.action, loopDelta: e.loopDelta});\n    });\n    this.mixer.addEventListener('finished', (e) => {\n      el.emit('animation-finished', {action: e.action, direction: e.direction});\n    });\n    if (this.data.clip) this.update({});\n  },\n\n  remove: function () {\n    if (this.mixer) this.mixer.stopAllAction();\n  },\n\n  update: function (prevData) {\n    if (!prevData) return;\n\n    const data = this.data;\n    const changes = AFRAME.utils.diff(data, prevData);\n\n    // If selected clips have changed, restart animation.\n    if ('clip' in changes) {\n      this.stopAction();\n      if (data.clip) this.playAction();\n      return;\n    }\n\n    // Otherwise, modify running actions.\n    this.activeActions.forEach((action) => {\n      if ('duration' in changes && data.duration) {\n        action.setDuration(data.duration);\n      }\n      if ('clampWhenFinished' in changes) {\n        action.clampWhenFinished = data.clampWhenFinished;\n      }\n      if ('loop' in changes || 'repetitions' in changes) {\n        action.setLoop(LoopMode[data.loop], data.repetitions);\n      }\n      if ('timeScale' in changes) {\n        action.setEffectiveTimeScale(data.timeScale);\n      }\n    });\n  },\n\n  stopAction: function () {\n    const data = this.data;\n    for (let i = 0; i < this.activeActions.length; i++) {\n      data.crossFadeDuration\n        ? this.activeActions[i].fadeOut(data.crossFadeDuration)\n        : this.activeActions[i].stop();\n    }\n    this.activeActions.length = 0;\n  },\n\n  playAction: function () {\n    if (!this.mixer) return;\n\n    const model = this.model,\n        data = this.data,\n        clips = model.animations || (model.geometry || {}).animations || [];\n\n    if (!clips.length) return;\n\n    const re = wildcardToRegExp(data.clip);\n\n    for (let clip, i = 0; (clip = clips[i]); i++) {\n      if (clip.name.match(re)) {\n        const action = this.mixer.clipAction(clip, model);\n        action.enabled = true;\n        action.clampWhenFinished = data.clampWhenFinished;\n        if (data.duration) action.setDuration(data.duration);\n        if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);\n        action\n          .setLoop(LoopMode[data.loop], data.repetitions)\n          .fadeIn(data.crossFadeDuration)\n          .play();\n        this.activeActions.push(action);\n      }\n    }\n  },\n\n  tick: function (t, dt) {\n    if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1000);\n  }\n});\n\n/**\n * Creates a RegExp from the given string, converting asterisks to .* expressions,\n * and escaping all other characters.\n */\nfunction wildcardToRegExp (s) {\n  return new RegExp('^' + s.split(/\\*+/).map(regExpEscape).join('.*') + '$');\n}\n\n/**\n * RegExp-escapes all characters in the given string.\n */\nfunction regExpEscape (s) {\n  return s.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n}\n"]},"metadata":{},"sourceType":"script"}