{"ast":null,"code":"module.exports = AFRAME.registerComponent('nav-agent', {\n  schema: {\n    destination: {\n      type: 'vec3'\n    },\n    active: {\n      default: false\n    },\n    speed: {\n      default: 2\n    }\n  },\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.system.addAgent(this);\n    this.group = null;\n    this.path = [];\n    this.raycaster = new THREE.Raycaster();\n  },\n  remove: function () {\n    this.system.removeAgent(this);\n  },\n  update: function () {\n    this.path.length = 0;\n  },\n  updateNavLocation: function () {\n    this.group = null;\n    this.path = [];\n  },\n  tick: function () {\n    const vDest = new THREE.Vector3();\n    const vDelta = new THREE.Vector3();\n    const vNext = new THREE.Vector3();\n    return function (t, dt) {\n      const el = this.el;\n      const data = this.data;\n      const raycaster = this.raycaster;\n      const speed = data.speed * dt / 1000;\n      if (!data.active) return; // Use PatrolJS pathfinding system to get shortest path to target.\n\n      if (!this.path.length) {\n        const position = this.el.object3D.position;\n        this.group = this.group || this.system.getGroup(position);\n        this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];\n        el.emit('navigation-start');\n      } // If no path is found, exit.\n\n\n      if (!this.path.length) {\n        console.warn('[nav] Unable to find path to %o.', data.destination);\n        this.el.setAttribute('nav-agent', {\n          active: false\n        });\n        el.emit('navigation-end');\n        return;\n      } // Current segment is a vector from current position to next waypoint.\n\n\n      const vCurrent = el.object3D.position;\n      const vWaypoint = this.path[0];\n      vDelta.subVectors(vWaypoint, vCurrent);\n      const distance = vDelta.length();\n      let gazeTarget;\n\n      if (distance < speed) {\n        // If <1 step from current waypoint, discard it and move toward next.\n        this.path.shift(); // After discarding the last waypoint, exit pathfinding.\n\n        if (!this.path.length) {\n          this.el.setAttribute('nav-agent', {\n            active: false\n          });\n          el.emit('navigation-end');\n          return;\n        }\n\n        vNext.copy(vCurrent);\n        gazeTarget = this.path[0];\n      } else {\n        // If still far away from next waypoint, find next position for\n        // the current frame.\n        vNext.copy(vDelta.setLength(speed)).add(vCurrent);\n        gazeTarget = vWaypoint;\n      } // Look at the next waypoint.\n\n\n      gazeTarget.y = vCurrent.y;\n      el.object3D.lookAt(gazeTarget); // Raycast against the nav mesh, to keep the agent moving along the\n      // ground, not traveling in a straight line from higher to lower waypoints.\n\n      raycaster.ray.origin.copy(vNext);\n      raycaster.ray.origin.y += 1.5;\n      raycaster.ray.direction.y = -1;\n      const intersections = raycaster.intersectObject(this.system.getNavMesh());\n\n      if (!intersections.length) {\n        // Raycasting failed. Step toward the waypoint and hope for the best.\n        vCurrent.copy(vNext);\n      } else {\n        // Re-project next position onto nav mesh.\n        vDelta.subVectors(intersections[0].point, vCurrent);\n        vCurrent.add(vDelta.setLength(speed));\n      }\n    };\n  }()\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/pathfinding/nav-agent.js"],"names":["module","exports","AFRAME","registerComponent","schema","destination","type","active","default","speed","init","system","el","sceneEl","systems","nav","addAgent","group","path","raycaster","THREE","Raycaster","remove","removeAgent","update","length","updateNavLocation","tick","vDest","Vector3","vDelta","vNext","t","dt","data","position","object3D","getGroup","getPath","copy","emit","console","warn","setAttribute","vCurrent","vWaypoint","subVectors","distance","gazeTarget","shift","setLength","add","y","lookAt","ray","origin","direction","intersections","intersectObject","getNavMesh","point"],"mappings":"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","sourcesContent":["module.exports = AFRAME.registerComponent('nav-agent', {\n  schema: {\n    destination: {type: 'vec3'},\n    active: {default: false},\n    speed: {default: 2}\n  },\n  init: function () {\n    this.system = this.el.sceneEl.systems.nav;\n    this.system.addAgent(this);\n    this.group = null;\n    this.path = [];\n    this.raycaster = new THREE.Raycaster();\n  },\n  remove: function () {\n    this.system.removeAgent(this);\n  },\n  update: function () {\n    this.path.length = 0;\n  },\n  updateNavLocation: function () {\n    this.group = null;\n    this.path = [];\n  },\n  tick: (function () {\n    const vDest = new THREE.Vector3();\n    const vDelta = new THREE.Vector3();\n    const vNext = new THREE.Vector3();\n\n    return function (t, dt) {\n      const el = this.el;\n      const data = this.data;\n      const raycaster = this.raycaster;\n      const speed = data.speed * dt / 1000;\n\n      if (!data.active) return;\n\n      // Use PatrolJS pathfinding system to get shortest path to target.\n      if (!this.path.length) {\n        const position = this.el.object3D.position;\n        this.group = this.group || this.system.getGroup(position);\n        this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];\n        el.emit('navigation-start');\n      }\n\n      // If no path is found, exit.\n      if (!this.path.length) {\n        console.warn('[nav] Unable to find path to %o.', data.destination);\n        this.el.setAttribute('nav-agent', {active: false});\n        el.emit('navigation-end');\n        return;\n      }\n\n      // Current segment is a vector from current position to next waypoint.\n      const vCurrent = el.object3D.position;\n      const vWaypoint = this.path[0];\n      vDelta.subVectors(vWaypoint, vCurrent);\n\n      const distance = vDelta.length();\n      let gazeTarget;\n\n      if (distance < speed) {\n        // If <1 step from current waypoint, discard it and move toward next.\n        this.path.shift();\n\n        // After discarding the last waypoint, exit pathfinding.\n        if (!this.path.length) {\n          this.el.setAttribute('nav-agent', {active: false});\n          el.emit('navigation-end');\n          return;\n        }\n\n        vNext.copy(vCurrent);\n        gazeTarget = this.path[0];\n      } else {\n        // If still far away from next waypoint, find next position for\n        // the current frame.\n        vNext.copy(vDelta.setLength(speed)).add(vCurrent);\n        gazeTarget = vWaypoint;\n      }\n\n      // Look at the next waypoint.\n      gazeTarget.y = vCurrent.y;\n      el.object3D.lookAt(gazeTarget);\n\n      // Raycast against the nav mesh, to keep the agent moving along the\n      // ground, not traveling in a straight line from higher to lower waypoints.\n      raycaster.ray.origin.copy(vNext);\n      raycaster.ray.origin.y += 1.5;\n      raycaster.ray.direction.y = -1;\n      const intersections = raycaster.intersectObject(this.system.getNavMesh());\n\n      if (!intersections.length) {\n        // Raycasting failed. Step toward the waypoint and hope for the best.\n        vCurrent.copy(vNext);\n      } else {\n        // Re-project next position onto nav mesh.\n        vDelta.subVectors(intersections[0].point, vCurrent);\n        vCurrent.add(vDelta.setLength(speed));\n      }\n\n    };\n  }())\n});\n"]},"metadata":{},"sourceType":"script"}