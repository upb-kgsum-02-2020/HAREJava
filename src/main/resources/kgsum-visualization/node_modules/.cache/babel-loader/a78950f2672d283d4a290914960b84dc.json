{"ast":null,"code":"var e = function () {};\n\ne.computeCentroids = function (e) {\n  var t, n, r;\n\n  for (t = 0, n = e.faces.length; t < n; t++) (r = e.faces[t]).centroid = new THREE.Vector3(0, 0, 0), r.centroid.add(e.vertices[r.a]), r.centroid.add(e.vertices[r.b]), r.centroid.add(e.vertices[r.c]), r.centroid.divideScalar(3);\n}, e.roundNumber = function (e, t) {\n  return Number(e.toFixed(t));\n}, e.sample = function (e) {\n  return e[Math.floor(Math.random() * e.length)];\n}, e.mergeVertexIds = function (e, t) {\n  var n = [];\n  if (e.forEach(function (e) {\n    t.indexOf(e) >= 0 && n.push(e);\n  }), n.length < 2) return [];\n  n.includes(e[0]) && n.includes(e[e.length - 1]) && e.push(e.shift()), n.includes(t[0]) && n.includes(t[t.length - 1]) && t.push(t.shift()), n = [], e.forEach(function (e) {\n    t.includes(e) && n.push(e);\n  });\n\n  for (var r = n[1], o = n[0], i = e.slice(); i[0] !== r;) i.push(i.shift());\n\n  for (var s = 0, u = t.slice(); u[0] !== o;) if (u.push(u.shift()), s++ > 10) throw new Error(\"Unexpected state\");\n\n  return u.shift(), u.pop(), i = i.concat(u);\n}, e.setPolygonCentroid = function (e, t) {\n  var n = new THREE.Vector3(),\n      r = t.vertices;\n  e.vertexIds.forEach(function (e) {\n    n.add(r[e]);\n  }), n.divideScalar(e.vertexIds.length), e.centroid.copy(n);\n}, e.cleanPolygon = function (e, t) {\n  for (var n = [], r = t.vertices, o = 0; o < e.vertexIds.length; o++) {\n    var i,\n        s,\n        u,\n        c = r[e.vertexIds[o]];\n    0 === o ? (i = e.vertexIds[1], s = e.vertexIds[e.vertexIds.length - 1]) : o === e.vertexIds.length - 1 ? (i = e.vertexIds[0], s = e.vertexIds[e.vertexIds.length - 2]) : (i = e.vertexIds[o + 1], s = e.vertexIds[o - 1]), u = r[s];\n    var h = r[i].clone().sub(c),\n        a = u.clone().sub(c),\n        d = h.angleTo(a);\n\n    if (d > Math.PI - .01 && d < Math.PI + .01) {\n      var f = [];\n      e.neighbours.forEach(function (t) {\n        t.vertexIds.includes(e.vertexIds[o]) || f.push(t);\n      }), e.neighbours = f;\n    } else n.push(e.vertexIds[o]);\n  }\n\n  e.vertexIds = n, this.setPolygonCentroid(e, t);\n}, e.isConvex = function (e, t) {\n  var n = t.vertices;\n  if (e.vertexIds.length < 3) return !1;\n\n  for (var r = !0, o = [], i = 0; i < e.vertexIds.length; i++) {\n    var s,\n        u,\n        c = n[e.vertexIds[i]];\n    0 === i ? (s = n[e.vertexIds[1]], u = n[e.vertexIds[e.vertexIds.length - 1]]) : i === e.vertexIds.length - 1 ? (s = n[e.vertexIds[0]], u = n[e.vertexIds[e.vertexIds.length - 2]]) : (s = n[e.vertexIds[i + 1]], u = n[e.vertexIds[i - 1]]);\n    var h = s.clone().sub(c),\n        a = u.clone().sub(c),\n        d = h.angleTo(a);\n    if (d === Math.PI || 0 === d) return !1;\n    var f = h.cross(a).y;\n    o.push(f);\n  }\n\n  return o.forEach(function (e) {\n    0 === e && (r = !1);\n  }), o.forEach(o[0] > 0 ? function (e) {\n    e < 0 && (r = !1);\n  } : function (e) {\n    e > 0 && (r = !1);\n  }), r;\n}, e.distanceToSquared = function (e, t) {\n  var n = e.x - t.x,\n      r = e.y - t.y,\n      o = e.z - t.z;\n  return n * n + r * r + o * o;\n}, e.isPointInPoly = function (e, t) {\n  for (var n = !1, r = -1, o = e.length, i = o - 1; ++r < o; i = r) (e[r].z <= t.z && t.z < e[i].z || e[i].z <= t.z && t.z < e[r].z) && t.x < (e[i].x - e[r].x) * (t.z - e[r].z) / (e[i].z - e[r].z) + e[r].x && (n = !n);\n\n  return n;\n}, e.isVectorInPolygon = function (e, t, n) {\n  var r = 1e5,\n      o = -1e5,\n      i = [];\n  return t.vertexIds.forEach(function (e) {\n    r = Math.min(n[e].y, r), o = Math.max(n[e].y, o), i.push(n[e]);\n  }), !!(e.y < o + .5 && e.y > r - .5 && this.isPointInPoly(i, e));\n}, e.triarea2 = function (e, t, n) {\n  return (n.x - e.x) * (t.z - e.z) - (t.x - e.x) * (n.z - e.z);\n}, e.vequal = function (e, t) {\n  return this.distanceToSquared(e, t) < 1e-5;\n};\n\nvar t = function (e) {\n  this.content = [], this.scoreFunction = e;\n};\n\nt.prototype.push = function (e) {\n  this.content.push(e), this.sinkDown(this.content.length - 1);\n}, t.prototype.pop = function () {\n  var e = this.content[0],\n      t = this.content.pop();\n  return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), e;\n}, t.prototype.remove = function (e) {\n  var t = this.content.indexOf(e),\n      n = this.content.pop();\n  t !== this.content.length - 1 && (this.content[t] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.sinkDown(t) : this.bubbleUp(t));\n}, t.prototype.size = function () {\n  return this.content.length;\n}, t.prototype.rescoreElement = function (e) {\n  this.sinkDown(this.content.indexOf(e));\n}, t.prototype.sinkDown = function (e) {\n  for (var t = this.content[e]; e > 0;) {\n    var n = (e + 1 >> 1) - 1,\n        r = this.content[n];\n    if (!(this.scoreFunction(t) < this.scoreFunction(r))) break;\n    this.content[n] = t, this.content[e] = r, e = n;\n  }\n}, t.prototype.bubbleUp = function (e) {\n  for (var t = this.content.length, n = this.content[e], r = this.scoreFunction(n);;) {\n    var o = e + 1 << 1,\n        i = o - 1,\n        s = null,\n        u = void 0;\n    if (i < t) (u = this.scoreFunction(this.content[i])) < r && (s = i);\n    if (o < t) this.scoreFunction(this.content[o]) < (null === s ? r : u) && (s = o);\n    if (null === s) break;\n    this.content[e] = this.content[s], this.content[s] = n, e = s;\n  }\n};\n\nvar n = function () {};\n\nn.init = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    n.f = 0, n.g = 0, n.h = 0, n.cost = 1, n.visited = !1, n.closed = !1, n.parent = null;\n  }\n}, n.cleanUp = function (e) {\n  for (var t = 0; t < e.length; t++) {\n    var n = e[t];\n    delete n.f, delete n.g, delete n.h, delete n.cost, delete n.visited, delete n.closed, delete n.parent;\n  }\n}, n.heap = function () {\n  return new t(function (e) {\n    return e.f;\n  });\n}, n.search = function (e, t, n) {\n  this.init(e);\n  var r = this.heap();\n\n  for (r.push(t); r.size() > 0;) {\n    var o = r.pop();\n\n    if (o === n) {\n      for (var i = o, s = []; i.parent;) s.push(i), i = i.parent;\n\n      return this.cleanUp(s), s.reverse();\n    }\n\n    o.closed = !0;\n\n    for (var u = this.neighbours(e, o), c = 0, h = u.length; c < h; c++) {\n      var a = u[c];\n\n      if (!a.closed) {\n        var d = o.g + a.cost,\n            f = a.visited;\n\n        if (!f || d < a.g) {\n          if (a.visited = !0, a.parent = o, !a.centroid || !n.centroid) throw new Error(\"Unexpected state\");\n          a.h = a.h || this.heuristic(a.centroid, n.centroid), a.g = d, a.f = a.g + a.h, f ? r.rescoreElement(a) : r.push(a);\n        }\n      }\n    }\n  }\n\n  return [];\n}, n.heuristic = function (t, n) {\n  return e.distanceToSquared(t, n);\n}, n.neighbours = function (e, t) {\n  for (var n = [], r = 0; r < t.neighbours.length; r++) n.push(e[t.neighbours[r]]);\n\n  return n;\n};\n\nvar r = 1,\n    o = function () {};\n\no.buildZone = function (t) {\n  var n = this,\n      r = this._buildNavigationMesh(t),\n      o = {};\n\n  r.vertices.forEach(function (t) {\n    t.x = e.roundNumber(t.x, 2), t.y = e.roundNumber(t.y, 2), t.z = e.roundNumber(t.z, 2);\n  }), o.vertices = r.vertices;\n\n  var i = this._buildPolygonGroups(r);\n\n  o.groups = [];\n\n  var s = function (e, t) {\n    for (var n = 0; n < e.length; n++) if (t === e[n]) return n;\n  };\n\n  return i.forEach(function (t) {\n    var r = [];\n    t.forEach(function (o) {\n      var i = o.neighbours.map(function (e) {\n        return s(t, e);\n      }),\n          u = o.neighbours.map(function (e) {\n        return n._getSharedVerticesInOrder(o, e);\n      });\n      o.centroid.x = e.roundNumber(o.centroid.x, 2), o.centroid.y = e.roundNumber(o.centroid.y, 2), o.centroid.z = e.roundNumber(o.centroid.z, 2), r.push({\n        id: s(t, o),\n        neighbours: i,\n        vertexIds: o.vertexIds,\n        centroid: o.centroid,\n        portals: u\n      });\n    }), o.groups.push(r);\n  }), o;\n}, o._buildNavigationMesh = function (t) {\n  return e.computeCentroids(t), t.mergeVertices(), this._buildPolygonsFromGeometry(t);\n}, o._buildPolygonGroups = function (e) {\n  var t = [],\n      n = 0,\n      r = function (e) {\n    e.neighbours.forEach(function (t) {\n      void 0 === t.group && (t.group = e.group, r(t));\n    });\n  };\n\n  return e.polygons.forEach(function (e) {\n    void 0 === e.group && (e.group = n++, r(e)), t[e.group] || (t[e.group] = []), t[e.group].push(e);\n  }), t;\n}, o._buildPolygonNeighbours = function (e, t, n) {\n  var r = new Set(),\n      o = n.get(e.vertexIds[0]),\n      i = n.get(e.vertexIds[1]),\n      s = n.get(e.vertexIds[2]);\n  o.forEach(function (e) {\n    (i.has(e) || s.has(e)) && r.add(t.polygons[e]);\n  }), i.forEach(function (e) {\n    s.has(e) && r.add(t.polygons[e]);\n  }), e.neighbours = Array.from(r);\n}, o._buildPolygonsFromGeometry = function (e) {\n  for (var t = this, n = [], o = e.vertices, i = e.faceVertexUvs, s = new Map(), u = 0; u < o.length; u++) s.set(u, new Set());\n\n  e.faces.forEach(function (e) {\n    n.push({\n      id: r++,\n      vertexIds: [e.a, e.b, e.c],\n      centroid: e.centroid,\n      normal: e.normal,\n      neighbours: []\n    }), s.get(e.a).add(n.length - 1), s.get(e.b).add(n.length - 1), s.get(e.c).add(n.length - 1);\n  });\n  var c = {\n    polygons: n,\n    vertices: o,\n    faceVertexUvs: i\n  };\n  return n.forEach(function (e) {\n    t._buildPolygonNeighbours(e, c, s);\n  }), c;\n}, o._getSharedVerticesInOrder = function (e, t) {\n  var n = e.vertexIds,\n      r = t.vertexIds,\n      o = new Set();\n  if (n.forEach(function (e) {\n    r.includes(e) && o.add(e);\n  }), o.size < 2) return [];\n  o.has(n[0]) && o.has(n[n.length - 1]) && n.push(n.shift()), o.has(r[0]) && o.has(r[r.length - 1]) && r.push(r.shift());\n  var i = [];\n  return n.forEach(function (e) {\n    r.includes(e) && i.push(e);\n  }), i;\n};\n\nvar i = function () {\n  this.portals = [];\n};\n\ni.prototype.push = function (e, t) {\n  void 0 === t && (t = e), this.portals.push({\n    left: e,\n    right: t\n  });\n}, i.prototype.stringPull = function () {\n  var t,\n      n,\n      r,\n      o = this.portals,\n      i = [],\n      s = 0,\n      u = 0,\n      c = 0;\n  n = o[0].left, r = o[0].right, i.push(t = o[0].left);\n\n  for (var h = 1; h < o.length; h++) {\n    var a = o[h].left,\n        d = o[h].right;\n\n    if (e.triarea2(t, r, d) <= 0) {\n      if (!(e.vequal(t, r) || e.triarea2(t, n, d) > 0)) {\n        i.push(n), n = t = n, r = t, u = s = u, c = s, h = s;\n        continue;\n      }\n\n      r = d, c = h;\n    }\n\n    if (e.triarea2(t, n, a) >= 0) {\n      if (!(e.vequal(t, n) || e.triarea2(t, r, a) < 0)) {\n        i.push(r), n = t = r, r = t, u = s = c, c = s, h = s;\n        continue;\n      }\n\n      n = a, u = h;\n    }\n  }\n\n  return 0 !== i.length && e.vequal(i[i.length - 1], o[o.length - 1].left) || i.push(o[o.length - 1].left), this.path = i, i;\n};\n\nvar s,\n    u,\n    c,\n    h,\n    a,\n    d,\n    f = function () {\n  this.zones = {};\n};\n\nf.createZone = function (e) {\n  return o.buildZone(e);\n}, f.prototype.setZoneData = function (e, t) {\n  this.zones[e] = t;\n}, f.prototype.getGroup = function (t, n) {\n  if (!this.zones[t]) return null;\n  var r = null,\n      o = Math.pow(50, 2);\n  return this.zones[t].groups.forEach(function (t, i) {\n    t.forEach(function (t) {\n      var s = e.distanceToSquared(t.centroid, n);\n      s < o && (r = i, o = s);\n    });\n  }), r;\n}, f.prototype.getRandomNode = function (t, n, r, o) {\n  if (!this.zones[t]) return new THREE.Vector3();\n  r = r || null, o = o || 0;\n  var i = [];\n  return this.zones[t].groups[n].forEach(function (t) {\n    r && o ? e.distanceToSquared(r, t.centroid) < o * o && i.push(t.centroid) : i.push(t.centroid);\n  }), e.sample(i) || new THREE.Vector3();\n}, f.prototype.getClosestNode = function (t, n, r, o) {\n  void 0 === o && (o = !1);\n  var i = this.zones[n].vertices,\n      s = null,\n      u = Infinity;\n  return this.zones[n].groups[r].forEach(function (n) {\n    var r = e.distanceToSquared(n.centroid, t);\n    r < u && (!o || e.isVectorInPolygon(t, n, i)) && (s = n, u = r);\n  }), s;\n}, f.prototype.findPath = function (e, t, r, o) {\n  var s = this.zones[r].groups[o],\n      u = this.zones[r].vertices,\n      c = this.getClosestNode(e, r, o),\n      h = this.getClosestNode(t, r, o, !0);\n  if (!c || !h) return null;\n\n  var a = n.search(s, c, h),\n      d = function (e, t) {\n    for (var n = 0; n < e.neighbours.length; n++) if (e.neighbours[n] === t.id) return e.portals[n];\n  },\n      f = new i();\n\n  f.push(e);\n\n  for (var l = 0; l < a.length; l++) {\n    var v = a[l + 1];\n\n    if (v) {\n      var p = d(a[l], v);\n      f.push(u[p[0]], u[p[1]]);\n    }\n  }\n\n  f.push(t), f.stringPull();\n  var g = f.path.map(function (e) {\n    return new THREE.Vector3(e.x, e.y, e.z);\n  });\n  return g.shift(), g;\n}, f.prototype.clampStep = (c = new THREE.Vector3(), h = new THREE.Plane(), a = new THREE.Triangle(), d = new THREE.Vector3(), function (e, t, n, r, o, i) {\n  var f = this.zones[r].vertices,\n      l = this.zones[r].groups[o],\n      v = [n],\n      p = {};\n  p[n.id] = 0, s = void 0, d.set(0, 0, 0), u = Infinity, h.setFromCoplanarPoints(f[n.vertexIds[0]], f[n.vertexIds[1]], f[n.vertexIds[2]]), h.projectPoint(t, c), t.copy(c);\n\n  for (var g = v.pop(); g; g = v.pop()) {\n    a.set(f[g.vertexIds[0]], f[g.vertexIds[1]], f[g.vertexIds[2]]), a.closestPointToPoint(t, c), c.distanceToSquared(t) < u && (s = g, d.copy(c), u = c.distanceToSquared(t));\n    var x = p[g];\n    if (!(x > 2)) for (var I = 0; I < g.neighbours.length; I++) {\n      var b = l[g.neighbours[I]];\n      b.id in p || (v.push(b), p[b.id] = x + 1);\n    }\n  }\n\n  return i.copy(d), s;\n});\nexport { f as Pathfinding };","map":{"version":3,"sources":["../src/Utils.js","../src/BinaryHeap.js","../src/AStar.js","../src/Builder.js","../src/Channel.js","../src/index.js"],"names":["Utils","computeCentroids","geometry","f","fl","face","faces","length","centroid","THREE","Vector3","add","vertices","a","b","c","divideScalar","roundNumber","value","decimals","Number","toFixed","sample","list","Math","floor","random","mergeVertexIds","aList","bList","sharedVertices","forEach","vID","indexOf","push","includes","shift","vId","clockwiseMostSharedVertex","counterClockwiseMostSharedVertex","cList","slice","temp","Error","pop","concat","setPolygonCentroid","polygon","navigationMesh","sum","vertexIds","copy","cleanPolygon","newVertexIds","i","vertex","nextVertexId","previousVertexId","previousVertex","clone","sub","angle","angleTo","PI","goodNeighbours","neighbours","neighbour","isConvex","convex","results","nextVertex","r","cross","y","distanceToSquared","dx","x","dy","dz","z","isPointInPoly","poly","pt","l","j","isVectorInPolygon","vector","lowestPoint","highestPoint","polygonVertices","min","max","this","triarea2","vequal","BinaryHeap","scoreFunction","content","element","sinkDown","result","end","bubbleUp","remove","node","const","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","swap","child1Score","AStar","init","graph","let","g","h","cost","visited","closed","cleanUp","heap","search","start","openHeap","currentNode","curr","ret","reverse","il","gScore","beenVisited","heuristic","pos1","pos2","e","polygonId","Builder","buildZone","navMesh","_buildNavigationMesh","zone","v","groups","_buildPolygonGroups","findPolygonIndex","group","p","newGroup","map","portals","_getSharedVerticesInOrder","id","mergeVertices","_buildPolygonsFromGeometry","polygons","polygonGroups","groupCount","spreadGroupId","undefined","_buildPolygonNeighbours","vertexPolygonMap","neighbors","Set","groupA","get","groupB","groupC","candidate","has","Array","from","faceVertexUvs","Map","set","normal","sharedVerticesOrdered","Channel","p1","p2","stringPull","pts","portalApex","portalLeft","portalRight","apexIndex","leftIndex","rightIndex","left","right","path","Pathfinding","zones","createZone","setZoneData","zoneID","getGroup","position","closestNodeGroup","distance","pow","index","measuredDistance","getRandomNode","groupID","nearPosition","nearRange","candidates","getClosestNode","checkPolygon","closestNode","closestDistance","Infinity","findPath","startPosition","targetPosition","nodes","farthestNode","paths","getPortalFromTo","channel","nextPolygon","prototype","clampStep","point","plane","Plane","triangle","Triangle","closestPoint","endTarget","nodeQueue","nodeDepth","setFromCoplanarPoints","projectPoint","closestPointToPoint","depth"],"mappings":"AAAA,IAAMA,CAAAA,GAAAA,YAAAA,CAAAA,CAAN;;AAAMA,CAAAA,CAEGC,gBAFHD,GAEGC,UAAkBC,CAAlBD,EAAkBC;AACvB,MAAIC,CAAJ,EAAOC,CAAP,EAAWC,CAAX;;AAEA,OAAMF,CAAAA,GAAI,CAAJA,EAAOC,CAAAA,GAAKF,CAAAA,CAASI,KAATJ,CAAeK,MAAjC,EAAyCJ,CAAAA,GAAIC,CAA7C,EAAiDD,CAAAA,EAAjD,EAAiDA,CAAAA,CAAAA,GAExCD,CAAAA,CAASI,KAATJ,CAAgBC,CAAhBD,CAFwCC,EAG1CK,QAH0CL,GAG/B,IAAIM,KAAAA,CAAMC,OAAV,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,CAH+BP,EAK/CE,CAAAA,CAAKG,QAALH,CAAcM,GAAdN,CAAmBH,CAAAA,CAASU,QAATV,CAAmBG,CAAAA,CAAKQ,CAAxBX,CAAnBG,CAL+CF,EAM/CE,CAAAA,CAAKG,QAALH,CAAcM,GAAdN,CAAmBH,CAAAA,CAASU,QAATV,CAAmBG,CAAAA,CAAKS,CAAxBZ,CAAnBG,CAN+CF,EAO/CE,CAAAA,CAAKG,QAALH,CAAcM,GAAdN,CAAmBH,CAAAA,CAASU,QAATV,CAAmBG,CAAAA,CAAKU,CAAxBb,CAAnBG,CAP+CF,EAOJY,CAAAA,CACtCP,QADsCO,CAC7BC,YAD6BD,CACf,CADeA,CAPIZ;AAQnB,CAb5BH,EAa4B,CAAA,CAKzBiB,WALyB,GAKzBA,UAAaC,CAAbD,EAAoBE,CAApBF,EAAoBE;AAAAA,SAClBC,MAAAA,CAAOF,CAAAA,CAAMG,OAANH,CAAcC,CAAdD,CAAPE,CADkBD;AACGA,CAnB1BnB,EAmB0BmB,CAAAA,CAGvBG,MAHuBH,GAGvBG,UAAQC,CAARD,EAAQC;AACb,SAAOA,CAAAA,CAAKC,IAAAA,CAAKC,KAALD,CAAWA,IAAAA,CAAKE,MAALF,KAAgBD,CAAAA,CAAKhB,MAAhCiB,CAALD,CAAP;AAA4ChB,CAvB1CP,EAuB0CO,CAAAA,CAGvCoB,cAHuCpB,GAGvCoB,UAAgBC,CAAhBD,EAAuBE,CAAvBF,EAAuBE;AAE5B,MAAIC,CAAAA,GAAAA,EAAJ;AAQA,MANAF,CAAAA,CAAMG,OAANH,CAAMG,UAASC,CAATD,EAASC;AACTH,IAAAA,CAAAA,CAAMI,OAANJ,CAAcG,CAAdH,KAAsB,CAAtBA,IACFC,CAAAA,CAAeI,IAAfJ,CAAoBE,CAApBF,CADED;AACkBG,GAFxBJ,GAMIE,CAAAA,CAAevB,MAAfuB,GAAwB,CAA5B,EAA+B,OAAA,EAAA;AAE3BA,EAAAA,CAAAA,CAAeK,QAAfL,CAAwBF,CAAAA,CAAM,CAANA,CAAxBE,KAAqCA,CAAAA,CAAeK,QAAfL,CAAwBF,CAAAA,CAAMA,CAAAA,CAAMrB,MAANqB,GAAe,CAArBA,CAAxBE,CAArCA,IAAkF,CAAA,CAE9EI,IAF8E,CAEzEN,CAAAA,CAAMQ,KAANR,EAFyE,CAAlFE,EAKAA,CAAAA,CAAeK,QAAfL,CAAwBD,CAAAA,CAAM,CAANA,CAAxBC,KAAqCA,CAAAA,CAAeK,QAAfL,CAAwBD,CAAAA,CAAMA,CAAAA,CAAMtB,MAANsB,GAAe,CAArBA,CAAxBC,CAArCA,IAAkF,CAAA,CAE9EI,IAF8E,CAEzEL,CAAAA,CAAMO,KAANP,EAFyE,CALlFC,EAOeM,CAAAA,GAAAA,EAPfN,EAaJF,CAAAA,CAAMG,OAANH,CAAMG,UAASM,CAATN,EAASM;AACTR,IAAAA,CAAAA,CAAMM,QAANN,CAAeQ,CAAfR,KACFC,CAAAA,CAAeI,IAAfJ,CAAoBO,CAApBP,CADED;AACkBQ,GAFxBT,CAbIE;;AAwBJ,OALA,IAAIQ,CAAAA,GAA4BR,CAAAA,CAAe,CAAfA,CAAhC,EACIS,CAAAA,GAAmCT,CAAAA,CAAe,CAAfA,CADvC,EAIIU,CAAAA,GAAQZ,CAAAA,CAAMa,KAANb,EACZ,EAAOY,CAAAA,CAAM,CAANA,CAAAA,KAAaF,CAApB,GAAoBA,CAAAA,CACZJ,IADYI,CACPE,CAAAA,CAAMJ,KAANI,EADOF;;AAOpB,OAHA,IAAIvB,CAAAA,GAAI,CAAR,EAEI2B,CAAAA,GAAOb,CAAAA,CAAMY,KAANZ,EACX,EAAOa,CAAAA,CAAK,CAALA,CAAAA,KAAYH,CAAnB,GAGE,IAAA,CAAA,CAFKL,IAEL,CAFUQ,CAAAA,CAAKN,KAALM,EAEV,GAAI3B,CAAAA,KAAM,EAAV,EAAc,MAAM,IAAI4B,KAAJ,CAAU,kBAAV,CAAN;;AAAgB,SAIhCD,CAAAA,CAAKN,KAALM,IACAA,CAAAA,CAAKE,GAALF,EADAA,EACKE,CAAAA,GAEGJ,CAAAA,CAAMK,MAANL,CAAaE,CAAbF,CAPwB;AAOXE,CA/EnB1C,EA+EmB0C,CAAAA,CAKhBI,kBALgBJ,GAKhBI,UAAoBC,CAApBD,EAA6BE,CAA7BF,EAA6BE;AAAAA,MAC9BC,CAAAA,GAAM,IAAIxC,KAAAA,CAAMC,OAAV,EADwBsC;AAAAA,MAG9BpC,CAAAA,GAAWoC,CAAAA,CAAepC,QAHIoC;AAGJpC,EAAAA,CAAAA,CAEtBsC,SAFsBtC,CAEZmB,OAFYnB,CAEZmB,UAASM,CAATN,EAASM;AAAAA,IAAAA,CAAAA,CACrB1B,GADqB0B,CACjBzB,CAAAA,CAASyB,CAATzB,CADiByB;AACRA,GAHWzB,GAGXyB,CAAAA,CAGfrB,YAHeqB,CAGFU,CAAAA,CAAQG,SAARH,CAAkBxC,MAHhB8B,CAHWzB,EAMKL,CAAAA,CAE3BC,QAF2BD,CAElB4C,IAFkB5C,CAEb0C,CAFa1C,CANLK;AAQRqC,CA/FpBjD,EA+FoBiD,CAAAA,CAGjBG,YAHiBH,GAGjBG,UAAcL,CAAdK,EAAuBJ,CAAvBI,EAAuBJ;AAM5B,OAJA,IAAIK,CAAAA,GAAAA,EAAJ,EAEIzC,CAAAA,GAAWoC,CAAAA,CAAepC,QAF9B,EAIS0C,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIP,CAAAA,CAAQG,SAARH,CAAkBxC,MAAtC,EAA8C+C,CAAAA,EAA9C,EAAmD;AAEjD,QAEIE,CAFJ;AAAA,QAEkBC,CAFlB;AAAA,QAGgBC,CAHhB;AAAA,QAAIH,CAAAA,GAAS3C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkBO,CAAlBP,CAATnC,CAAb;AAKU,UAAN0C,CAAM,IAANA,CAAAA,GACaP,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CADbO,EAEFG,CAAAA,GAAmBV,CAAAA,CAAQG,SAARH,CAAkBA,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAA7CA,CAFX,IAGCO,CAAAA,KAAMP,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAAjCO,IAAiC,CAAA,GAC3BP,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CAD2B,EAE1CU,CAAAA,GAAmBV,CAAAA,CAAQG,SAARH,CAAkBA,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAA7CA,CAFVO,KAEuD,CAAA,GAEjDP,CAAAA,CAAQG,SAARH,CAAkBO,CAAAA,GAAI,CAAtBP,CAFiD,EAE3B,CAAA,GAClBA,CAAAA,CAAQG,SAARH,CAAkBO,CAAAA,GAAI,CAAtBP,CALVO,CAHD,EAYVI,CAAAA,GAAiB9C,CAAAA,CAAS6C,CAAT7C,CAZP;AAcV,QAAIC,CAAAA,GAHSD,CAAAA,CAAS4C,CAAT5C,CAAAA,CAGM+C,KAHN/C,GAGcgD,GAHdhD,CAGkB2C,CAHlB3C,CAGb;AAAA,QACIE,CAAAA,GAAI4C,CAAAA,CAAeC,KAAfD,GAAuBE,GAAvBF,CAA2BH,CAA3BG,CADR;AAAA,QAGIG,CAAAA,GAAQhD,CAAAA,CAAEiD,OAAFjD,CAAUC,CAAVD,CAHZ;;AAKA,QAAIgD,CAAAA,GAAQrC,IAAAA,CAAKuC,EAALvC,GAAU,GAAlBqC,IAA0BA,CAAAA,GAAQrC,IAAAA,CAAKuC,EAALvC,GAAU,GAAhD,EAAsD;AAGpD,UAAIwC,CAAAA,GAAAA,EAAJ;AAAIA,MAAAA,CAAAA,CACIC,UADJD,CACejC,OADfiC,CACejC,UAASmC,CAATnC,EAASmC;AACrBA,QAAAA,CAAAA,CAAUhB,SAAVgB,CAAoB/B,QAApB+B,CAA6BnB,CAAAA,CAAQG,SAARH,CAAkBO,CAAlBP,CAA7BmB,KACHF,CAAAA,CAAe9B,IAAf8B,CAAoBE,CAApBF,CADGE;AACiBA,OAHpBF,GAMJjB,CAAAA,CAAQkB,UAARlB,GAAqBiB,CANjBA;AAMiBA,KATvB,MASuBA,CAAAA,CAKR9B,IALQ8B,CAKHjB,CAAAA,CAAQG,SAARH,CAAkBO,CAAlBP,CALGiB;AAUzBjB;;AAAAA,EAAAA,CAAAA,CAAQG,SAARH,GAAoBM,CAApBN,EAAoBM,KAEfP,kBAFeO,CAEIN,CAFJM,EAEaL,CAFbK,CAApBN;AAEiCC,CAvJ/BhD,EAuJ+BgD,CAAAA,CAI5BmB,QAJ4BnB,GAI5BmB,UAAUpB,CAAVoB,EAAmBnB,CAAnBmB,EAAmBnB;AAExB,MAAIpC,CAAAA,GAAWoC,CAAAA,CAAepC,QAA9B;AAEA,MAAImC,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAA/B,EAAkC,OAAA,CAAO,CAAP;;AAQlC,OANA,IAAIqB,CAAAA,GAAAA,CAAS,CAAb,EAIIC,CAAAA,GAAAA,EAJJ,EAMSf,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIP,CAAAA,CAAQG,SAARH,CAAkBxC,MAAtC,EAA8C+C,CAAAA,EAA9C,EAAmD;AAEjD,QAEIgB,CAFJ;AAAA,QAEgBZ,CAFhB;AAAA,QAAIH,CAAAA,GAAS3C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkBO,CAAlBP,CAATnC,CAAb;AAIU,UAAN0C,CAAM,IAANA,CAAAA,GACW1C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CAATnC,CADX0C,EAEFI,CAAAA,GAAiB9C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkBA,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAA7CA,CAATnC,CAFT,IAGC0C,CAAAA,KAAMP,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAAjCO,IAAiC,CAAA,GAC7B1C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CAATnC,CAD6B,EAE1C8C,CAAAA,GAAiB9C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkBA,CAAAA,CAAQG,SAARH,CAAkBxC,MAAlBwC,GAA2B,CAA7CA,CAATnC,CAFR0C,KAITgB,CAAAA,GAAa1D,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkBO,CAAAA,GAAI,CAAtBP,CAATnC,CAAb0D,EACAZ,CAAAA,GAAiB9C,CAAAA,CAASmC,CAAAA,CAAQG,SAARH,CAAkBO,CAAAA,GAAI,CAAtBP,CAATnC,CALR0C,CAHD;AAWV,QAAIzC,CAAAA,GAAIyD,CAAAA,CAAWX,KAAXW,GAAmBV,GAAnBU,CAAuBf,CAAvBe,CAAR;AAAA,QACIxD,CAAAA,GAAI4C,CAAAA,CAAeC,KAAfD,GAAuBE,GAAvBF,CAA2BH,CAA3BG,CADR;AAAA,QAGIG,CAAAA,GAAQhD,CAAAA,CAAEiD,OAAFjD,CAAUC,CAAVD,CAHZ;AAGsBC,QAGlB+C,CAAAA,KAAUrC,IAAAA,CAAKuC,EAAfF,IAA+B,MAAVA,CAHH/C,EAGgB,OAAA,CAAO,CAAP;AAAO,QAEzCyD,CAAAA,GAAI1D,CAAAA,CAAE2D,KAAF3D,CAAQC,CAARD,EAAW4D,CAF0B;AAG7CJ,IAAAA,CAAAA,CAAQnC,IAARmC,CAAaE,CAAbF;AAAaE;;AAAAA,SAKfF,CAAAA,CAAQtC,OAARsC,CAAQtC,UAASwC,CAATxC,EAASwC;AACL,UAANA,CAAM,KAAGH,CAAAA,GAAAA,CAAS,CAAZ;AAAY,GADxBC,GAKEA,CAAAA,CAAQtC,OAARsC,CADEA,CAAAA,CAAQ,CAARA,CAAAA,GAAa,CAAbA,GAAa,UACEE,CADF,EACEA;AACXA,IAAAA,CAAAA,GAAI,CAAJA,KAAOH,CAAAA,GAAAA,CAAS,CAAhBG;AAAgB,GAFpBF,GAEoB,UAGLE,CAHK,EAGLA;AACXA,IAAAA,CAAAA,GAAI,CAAJA,KAAOH,CAAAA,GAAAA,CAAS,CAAhBG;AAAgB,GALtBF,CALFA,EAcOD,CAnBQG;AAmBRH,CApNLpE,EAoNKoE,CAAAA,CAGFM,iBAHEN,GAGFM,UAAmB7D,CAAnB6D,EAAsB5D,CAAtB4D,EAAsB5D;AAAAA,MAEvB6D,CAAAA,GAAK9D,CAAAA,CAAE+D,CAAF/D,GAAMC,CAAAA,CAAE8D,CAFU9D;AAAAA,MAGvB+D,CAAAA,GAAKhE,CAAAA,CAAE4D,CAAF5D,GAAMC,CAAAA,CAAE2D,CAHU3D;AAAAA,MAIvBgE,CAAAA,GAAKjE,CAAAA,CAAEkE,CAAFlE,GAAMC,CAAAA,CAAEiE,CAJUjE;AAM3B,SAAO6D,CAAAA,GAAKA,CAALA,GAAUE,CAAAA,GAAKA,CAAfF,GAAoBG,CAAAA,GAAKA,CAAhC;AAAgCA,CA7N9B9E,EA6N8B8E,CAAAA,CAM3BE,aAN2BF,GAM3BE,UAAeC,CAAfD,EAAqBE,CAArBF,EAAqBE;AAC1B,OAAK,IAAInE,CAAAA,GAAAA,CAAI,CAAR,EAAeuC,CAAAA,GAAAA,CAAK,CAApB,EAAuB6B,CAAAA,GAAIF,CAAAA,CAAK1E,MAAhC,EAAwC6E,CAAAA,GAAID,CAAAA,GAAI,CAArD,EAAqD,EAAK7B,CAAL,GAAS6B,CAA9D,EAAiEC,CAAAA,GAAI9B,CAArE,EAAqEA,CACjE2B,CAAAA,CAAK3B,CAAL2B,CAAAA,CAAQF,CAARE,IAAaC,CAAAA,CAAGH,CAAhBE,IAAqBC,CAAAA,CAAGH,CAAHG,GAAOD,CAAAA,CAAKG,CAALH,CAAAA,CAAQF,CAApCE,IAA2CA,CAAAA,CAAKG,CAALH,CAAAA,CAAQF,CAARE,IAAaC,CAAAA,CAAGH,CAAhBE,IAAqBC,CAAAA,CAAGH,CAAHG,GAAOD,CAAAA,CAAK3B,CAAL2B,CAAAA,CAAQF,CADdzB,KACsB4B,CAAAA,CAAGN,CAAHM,GAAGN,CAAKK,CAAAA,CAAKG,CAALH,CAAAA,CAAQL,CAARK,GAAYA,CAAAA,CAAK3B,CAAL2B,CAAAA,CAAQL,CAAzBA,KAA+BM,CAAAA,CAAGH,CAAHG,GAAOD,CAAAA,CAAK3B,CAAL2B,CAAAA,CAAQF,CAA9CH,KAAoDK,CAAAA,CAAKG,CAALH,CAAAA,CAAQF,CAARE,GAAYA,CAAAA,CAAK3B,CAAL2B,CAAAA,CAAQF,CAAxEH,IAA6EK,CAAAA,CAAK3B,CAAL2B,CAAAA,CAAQL,CAD9GtB,KACqHvC,CAAAA,GAAAA,CAAKA,CAD1HuC;;AAC0HvC,SACxLA,CADwLA;AACxLA,CAtOLf,EAsOKe,CAAAA,CAGFsE,iBAHEtE,GAGFsE,UAAmBC,CAAnBD,EAA2BtC,CAA3BsC,EAAoCzE,CAApCyE,EAAoCzE;AAKzC,MAAI2E,CAAAA,GAAc,GAAlB;AAAA,MACIC,CAAAA,GAAAA,CAAgB,GADpB;AAAA,MAGIC,CAAAA,GAAAA,EAHJ;AAGIA,SAAAA,CAAAA,CAEIvC,SAFJuC,CAEc1D,OAFd0D,CAEc1D,UAASM,CAATN,EAASM;AACzBkD,IAAAA,CAAAA,GAAc/D,IAAAA,CAAKkE,GAALlE,CAASZ,CAAAA,CAASyB,CAATzB,CAAAA,CAAc6D,CAAvBjD,EAA0B+D,CAA1B/D,CAAd+D,EACAC,CAAAA,GAAehE,IAAAA,CAAKmE,GAALnE,CAASZ,CAAAA,CAASyB,CAATzB,CAAAA,CAAc6D,CAAvBjD,EAA0BgE,CAA1BhE,CADf+D,EACyCC,CAAAA,CACzBtD,IADyBsD,CACpB5E,CAAAA,CAASyB,CAATzB,CADoB4E,CADzCD;AAE8BlD,GAL5BoD,GAK4BpD,CAAAA,EAG5BiD,CAAAA,CAAOb,CAAPa,GAAWE,CAAAA,GAAe,EAA1BF,IAAiCA,CAAAA,CAAOb,CAAPa,GAAWC,CAAAA,GAAc,EAA1DD,IACFM,KAAKZ,aAALY,CAAmBH,CAAnBG,EAAoCN,CAApCM,CAJ8BvD,CAL5BoD;AASkCH,CA1PpCtF,EA0PoCsF,CAAAA,CAMjCO,QANiCP,GAMjCO,UAAUhF,CAAVgF,EAAa/E,CAAb+E,EAAgB9E,CAAhB8E,EAAgB9E;AAAAA,SAAAA,CAGZA,CAAAA,CAAE6D,CAAF7D,GAAMF,CAAAA,CAAE+D,CAHI7D,KAEZD,CAAAA,CAAEiE,CAAFjE,GAAMD,CAAAA,CAAEkE,CAFIhE,IAEJgE,CADRjE,CAAAA,CAAE8D,CAAF9D,GAAMD,CAAAA,CAAE+D,CACAG,KAERhE,CAAAA,CAAEgE,CAAFhE,GAAMF,CAAAA,CAAEkE,CAFAA,CAFIhE;AAIJgE,CApQf/E,EAoQe+E,CAAAA,CAIZe,MAJYf,GAIZe,UAAQjF,CAARiF,EAAWhF,CAAXgF,EAAWhF;AAAAA,SACT8E,KAAKlB,iBAALkB,CAAuB/E,CAAvB+E,EAA0B9E,CAA1B8E,IAA+B,IADtB9E;AACsB,CAzQpCd;;ACKN,IAAM+F,CAAAA,GACJ,UAAaC,CAAb,EAAaA;AACXJ,OAAKK,OAALL,GAAKK,EAALL,EACAA,KAAKI,aAALJ,GAAqBI,CADrBJ;AACqBI,CAHzB;;AAGyBA,CAAAA,CAAAA,SAAAA,CAGvB9D,IAHuB8D,GAGvB9D,UAAMgE,CAANhE,EAAMgE;AAAAA,OAECD,OAFDC,CAEShE,IAFTgE,CAEcA,CAFdA,GAKJN,KAAKO,QAALP,CAAcA,KAAKK,OAALL,CAAarF,MAAbqF,GAAsB,CAApCA,CALIM;AAKgC,CARfF,EAQe,CAAA,CAAA,SAAA,CAGtCpD,GAHsC,GAGtCA,YAAAA;AAAAA,MAEQwD,CAAAA,GAASR,KAAKK,OAALL,CAAa,CAAbA,CAFjBhD;AAAAA,MAIQyD,CAAAA,GAAMT,KAAKK,OAALL,CAAahD,GAAbgD,EAJdhD;AAI2BA,SAGrBgD,KAAKK,OAALL,CAAarF,MAAbqF,GAAsB,CAAtBA,KAAsB,KACnBK,OADmB,CACX,CADW,IACNI,CADM,EAExBT,KAAKU,QAALV,CAAc,CAAdA,CAFEA,GAIGQ,CAPkBxD;AAOlBwD,CAtBcJ,EAsBdI,CAAAA,CAAAA,SAAAA,CAGTG,MAHSH,GAGTG,UAAQC,CAARD,EAAQC;AACNC,MAAMnD,CAAAA,GAAIsC,KAAKK,OAALL,CAAa3D,OAAb2D,CAAqBY,CAArBZ,CAAVa;AAAAA,MAIMJ,CAAAA,GAAMT,KAAKK,OAALL,CAAahD,GAAbgD,EAJZa;AAMInD,EAAAA,CAAAA,KAAMsC,KAAKK,OAALL,CAAarF,MAAbqF,GAAsB,CAA5BtC,KAA4B,KACzB2C,OADyB,CACjB3C,CADiB,IACZ+C,CADY,EAG1BT,KAAKI,aAALJ,CAAmBS,CAAnBT,IAA0BA,KAAKI,aAALJ,CAAmBY,CAAnBZ,CAA1BA,GACFA,KAAKO,QAALP,CAActC,CAAdsC,CADEA,GAGFA,KAAKU,QAALV,CAActC,CAAdsC,CANAtC;AAMcA,CAtCG0C,EAsCH1C,CAAAA,CAAAA,SAAAA,CAKpBoD,IALoBpD,GAKpBoD,YAAAA;AACE,SAAOd,KAAKK,OAALL,CAAarF,MAApB;AAAoBA,CA5CCyF,EA4CDzF,CAAAA,CAAAA,SAAAA,CAGtBoG,cAHsBpG,GAGtBoG,UAAgBH,CAAhBG,EAAgBH;AACdZ,OAAKO,QAALP,CAAcA,KAAKK,OAALL,CAAa3D,OAAb2D,CAAqBY,CAArBZ,CAAdA;AAAmCY,CAhDdR,EAgDcQ,CAAAA,CAAAA,SAAAA,CAGrCL,QAHqCK,GAGrCL,UAAUS,CAAVT,EAAUS;AAKR,OAAA,IAHMV,CAAAA,GAAUN,KAAKK,OAALL,CAAagB,CAAbhB,CAGhB,EAAOgB,CAAAA,GAAI,CAAX,GAAc;AAEZH,QAAMI,CAAAA,GAAAA,CAAYD,CAAAA,GAAI,CAAJA,IAAU,CAAtBC,IAA2B,CAAjCJ;AAAAA,QACMK,CAAAA,GAAAA,KAAcb,OAAda,CAAsBD,CAAtBC,CADNL;AAGA,QAAA,EAAA,KAAST,aAAT,CAAuBE,CAAvB,IAAuBA,KAAgBF,aAAhBE,CAA8BY,CAA9BZ,CAAvB,CAAA,EAQE;AAAA,SANKD,OAML,CANaY,CAMb,IANwBX,CAMxB,EANwBA,KACnBD,OADmBC,CACXU,CADWV,IACNY,CAKlB,EALkBA,CAAAA,GAEdD,CAGJ;AAHIA;AAAAA,CAlEab,EAkEba,CAAAA,CAAAA,SAAAA,CAQVP,QARUO,GAQVP,UAAUM,CAAVN,EAAUM;AAAAA,OAAAA,IAEFrG,CAAAA,GAASqF,KAAKK,OAALL,CAAarF,MAFpBqG,EAGNV,CAAAA,GAAUN,KAAKK,OAALL,CAAagB,CAAbhB,CAHJgB,EAING,CAAAA,GAAYnB,KAAKI,aAALJ,CAAmBM,CAAnBN,CAJNgB,IAMK;AAEXH,QAAMO,CAAAA,GAAWJ,CAAAA,GAAI,CAAJA,IAAU,CAA3BH;AAAAA,QACEQ,CAAAA,GAAUD,CAAAA,GAAU,CADtBP;AAAAA,QAIIS,CAAAA,GAAO,IAJXT;AAAAA,QAKIU,CAAAA,GAAAA,KAAAA,CALJV;AAOA,QAAIQ,CAAAA,GAAU1G,CAAd,EAAcA,CAAAA,CAAAA,GAAAA,KAGOyF,aAHPzF,CAGOyF,KADCC,OACDD,CADSiB,CACTjB,CAHPzF,CAAAA,IAMMwG,CANNxG,KAMMwG,CAAAA,GACTE,CAPG1G;AAYd,QAAIyG,CAAAA,GAAUzG,CAAd,EAAcA,KAESyF,aAFTzF,CAESyF,KADDC,OACCD,CADOgB,CACPhB,CAFTzF,KAGgB,SAAT2G,CAAS,GAAOH,CAAP,GAAmBI,CAHnC5G,MAGmC4G,CAAAA,GACtCH,CAJGzG;AASd,QAAa,SAAT2G,CAAJ,EAQE;AAAA,SAPKjB,OAOL,CAPaW,CAOb,IAPaA,KAAUX,OAAVW,CAAkBM,CAAlBN,CAOb,EAP+BM,KAC1BjB,OAD0BiB,CAClBA,CADkBA,IACVhB,CAMrB,EANqBA,CAAAA,GACjBgB,CAKJ;AALIA;AAAAA,CAjHalB;;ACLzB,IAAMoB,CAAAA,GAAAA,YAAAA,CAAAA,CAAN;;AAAMA,CAAAA,CACGC,IADHD,GACGC,UAAMC,CAAND,EAAMC;AACX,OAAKC,IAAI3C,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAI0C,CAAAA,CAAM/G,MAA1B,EAAkCqE,CAAAA,EAAlC,EAAuC;AAAA,QAE/B4B,CAAAA,GAAOc,CAAAA,CAAM1C,CAAN0C,CAFwB;AAGrCd,IAAAA,CAAAA,CAAKrG,CAALqG,GAAS,CAATA,EACAA,CAAAA,CAAKgB,CAALhB,GAAS,CADTA,EAEAA,CAAAA,CAAKiB,CAALjB,GAAS,CAFTA,EAGAA,CAAAA,CAAKkB,IAALlB,GAAY,CAHZA,EAIAA,CAAAA,CAAKmB,OAALnB,GAAKmB,CAAU,CAJfnB,EAKAA,CAAAA,CAAKoB,MAALpB,GAAKoB,CAAS,CALdpB,EAMAA,CAAAA,CAAKM,MAALN,GAAc,IANdA;AAMc;AAAA,CAXdY,EAWc,CAAA,CAIXS,OAJW,GAIXA,UAASP,CAATO,EAASP;AACd,OAAKC,IAAI3C,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAI0C,CAAAA,CAAM/G,MAA1B,EAAkCqE,CAAAA,EAAlC,EAAuC;AAAA,QAC/B4B,CAAAA,GAAOc,CAAAA,CAAM1C,CAAN0C,CADwB;AAClB1C,WACZ4B,CAAAA,CAAKrG,CADOyE,EACPzE,OACLqG,CAAAA,CAAKgB,CAFO5C,EAEP4C,OACLhB,CAAAA,CAAKiB,CAHO7C,EAGP6C,OACLjB,CAAAA,CAAKkB,IAJO9C,EAIP8C,OACLlB,CAAAA,CAAKmB,OALO/C,EAKP+C,OACLnB,CAAAA,CAAKoB,MANOhD,EAMPgD,OACLpB,CAAAA,CAAKM,MAPOlC;AAOPkC;AAAAA,CAxBZM,EAwBYN,CAAAA,CAITgB,IAJShB,GAITgB,YAAAA;AACL,SAAO,IAAI/B,CAAJ,CAAe,UAAUS,CAAV,EAAUA;AAC9B,WAAOA,CAAAA,CAAKrG,CAAZ;AAAYA,GADP,CAAP;AACcA,CA9BZiH,EA8BYjH,CAAAA,CAIT4H,MAJS5H,GAIT4H,UAAQT,CAARS,EAAeC,CAAfD,EAAsB1B,CAAtB0B,EAAsB1B;AAC3BT,OAAKyB,IAALzB,CAAU0B,CAAV1B;AAAU0B,MAIJW,CAAAA,GAAWrC,KAAKkC,IAALlC,EAJP0B;;AAQV,OAFAW,CAAAA,CAAS/F,IAAT+F,CAAcD,CAAdC,CAEA,EAAOA,CAAAA,CAASvB,IAATuB,KAAkB,CAAzB,GAA4B;AAAA,QAGpBC,CAAAA,GAAcD,CAAAA,CAASrF,GAATqF,EAHM;;AAM1B,QAAIC,CAAAA,KAAgB7B,CAApB,EAAyB;AAGvB,WAFAkB,IAAIY,CAAAA,GAAOD,CAAXX,EACMa,CAAAA,GAAAA,EACN,EAAOD,CAAAA,CAAKrB,MAAZ,GACEsB,CAAAA,CAAIlG,IAAJkG,CAASD,CAATC,GACAD,CAAAA,GAAOA,CAAAA,CAAKrB,MADZsB;;AAIF,aAAA,KADKP,OACL,CADaO,CACb,GAAOA,CAAAA,CAAIC,OAAJD,EAAP;AAIFF;;AAAAA,IAAAA,CAAAA,CAAYN,MAAZM,GAAYN,CAAS,CAArBM;;AAKA,SAFAzB,IAAMxC,CAAAA,GAAAA,KAAkBA,UAAlBA,CAA6BqD,CAA7BrD,EAAoCiE,CAApCjE,CAANwC,EAESnD,CAAAA,GAAI,CAFbmD,EAEgB6B,CAAAA,GAAKrE,CAAAA,CAAW1D,MAAhC,EAAwC+C,CAAAA,GAAIgF,CAA5C,EAAgDhF,CAAAA,EAAhD,EAAqD;AAAA,UAC7CY,CAAAA,GAAYD,CAAAA,CAAWX,CAAXW,CADiC;;AAGnD,UAAA,CAAIC,CAAAA,CAAU0D,MAAd,EAAA;AAAA,YAOMW,CAAAA,GAASL,CAAAA,CAAYV,CAAZU,GAAgBhE,CAAAA,CAAUwD,IAPzC;AAAA,YAQMc,CAAAA,GAActE,CAAAA,CAAUyD,OAR9B;;AAQ8BA,YAAAA,CAEzBa,CAFyBb,IAEVY,CAAAA,GAASrE,CAAAA,CAAUsD,CAFTG,EAEY;AAAA,cAGxCzD,CAAAA,CAAUyD,OAAVzD,GAAUyD,CAAU,CAApBzD,EACAA,CAAAA,CAAU4C,MAAV5C,GAAmBgE,CADnBhE,EACmBgE,CACdhE,CAAAA,CAAU1D,QADI0H,IACJ1H,CAAa6F,CAAAA,CAAI7F,QALQ,EAKE,MAAM,IAAImC,KAAJ,CAAU,kBAAV,CAAN;AAAgB,UAAA,CAAA,CAChD8E,CADgD,GAC5CvD,CAAAA,CAAUuD,CAAVvD,IAAUuD,KAAUgB,SAAVhB,CAAoBvD,CAAAA,CAAU1D,QAA9BiH,EAAwCpB,CAAAA,CAAI7F,QAA5CiH,CADkC,EAE1DvD,CAAAA,CAAUsD,CAAVtD,GAAcqE,CAF4C,EAE5CA,CAAAA,CACJpI,CADIoI,GACArE,CAAAA,CAAUsD,CAAVtD,GAAcA,CAAAA,CAAUuD,CAHoB,EAKrDe,CAAAA,GAKHP,CAAAA,CAAStB,cAATsB,CAAwB/D,CAAxB+D,CALGO,GAEHP,CAAAA,CAAS/F,IAAT+F,CAAc/D,CAAd+D,CAPwD;AAO1C/D;AAAAA;AAAAA;AAAAA;;AAAAA,SAAAA,EAAAA;AAAAA,CA3FpBkD,EA2FoBlD,CAAAA,CAajBuE,SAbiBvE,GAajBuE,UAAWC,CAAXD,EAAiBE,CAAjBF,EAAiBE;AAAAA,SACf3I,CAAAA,CAAM0E,iBAAN1E,CAAwB0I,CAAxB1I,EAA8B2I,CAA9B3I,CADe2I;AACeA,CAzGnCvB,EAyGmCuB,CAAAA,CAGhC1E,UAHgC0E,GAGhC1E,UAAYqD,CAAZrD,EAAmBuC,CAAnBvC,EAAmBuC;AAGxB,OAFAC,IAAM2B,CAAAA,GAAAA,EAAN3B,EAESmC,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIpC,CAAAA,CAAKvC,UAALuC,CAAgBjG,MAApC,EAA4CqI,CAAAA,EAA5C,EACER,CAAAA,CAAIlG,IAAJkG,CAASd,CAAAA,CAAMd,CAAAA,CAAKvC,UAALuC,CAAgBoC,CAAhBpC,CAANc,CAATc;;AAA+BQ,SAG1BR,CAH0BQ;AAG1BR,CAnHLhB;;ACDNG,IAAIsB,CAAAA,GAAY,CAAhBtB;AAAAA,IAEMuB,CAAAA,GAAAA,YAAAA,CAAAA,CAFNvB;;AAEMuB,CAAAA,CAMGC,SANHD,GAMGC,UAAW7I,CAAX6I,EAAW7I;AAAAA,MAAAA,CAAAA,GAAAA,IAAAA;AAAAA,MAEV8I,CAAAA,GAAUpD,KAAKqD,oBAALrD,CAA0B1F,CAA1B0F,CAFA1F;AAAAA,MAIVgJ,CAAAA,GAAAA,EAJUhJ;;AAIVgJ,EAAAA,CAAAA,CAEEtI,QAFFsI,CAEWnH,OAFXmH,CAEWnH,UAASoH,CAATpH,EAASoH;AACxBA,IAAAA,CAAAA,CAAEvE,CAAFuE,GAAMnJ,CAAAA,CAAMiB,WAANjB,CAAkBmJ,CAAAA,CAAEvE,CAApB5E,EAAuB,CAAvBA,CAANmJ,EACAA,CAAAA,CAAE1E,CAAF0E,GAAMnJ,CAAAA,CAAMiB,WAANjB,CAAkBmJ,CAAAA,CAAE1E,CAApBzE,EAAuB,CAAvBA,CADNmJ,EAEAA,CAAAA,CAAEpE,CAAFoE,GAAMnJ,CAAAA,CAAMiB,WAANjB,CAAkBmJ,CAAAA,CAAEpE,CAApB/E,EAAuB,CAAvBA,CAFNmJ;AAE6B,GALzBD,GAQNA,CAAAA,CAAKtI,QAALsI,GAAgBF,CAAAA,CAAQpI,QARlBsI;;AAQkBtI,MAElBwI,CAAAA,GAASxD,KAAKyD,mBAALzD,CAAyBoD,CAAzBpD,CAFShF;;AAIxBsI,EAAAA,CAAAA,CAAKE,MAALF,GAAKE,EAALF;;AAAKE,MAECE,CAAAA,GAAmB,UAAUC,CAAV,EAAiBC,CAAjB,EAAiBA;AACxC,SAAKjC,IAAIjE,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIiG,CAAAA,CAAMhJ,MAA1B,EAAkC+C,CAAAA,EAAlC,EACE,IAAIkG,CAAAA,KAAMD,CAAAA,CAAMjG,CAANiG,CAAV,EAAoB,OAAOjG,CAAP;AAAOA,GAJ1B8F;;AAI0B9F,SAO/B8F,CAAAA,CAAOrH,OAAPqH,CAAOrH,UAASwH,CAATxH,EAASwH;AAEd9C,QAAMgD,CAAAA,GAAAA,EAANhD;AAEA8C,IAAAA,CAAAA,CAAMxH,OAANwH,CAAMxH,UAASyH,CAATzH,EAASyH;AAAAA,UAGPvF,CAAAA,GAAauF,CAAAA,CAAEvF,UAAFuF,CAAaE,GAAbF,CAAaE,UAAK9C,CAAL8C,EAAK9C;AAAAA,eAAM0C,CAAAA,CAAiBC,CAAjBD,EAAwB1C,CAAxB0C,CAAN1C;AAA8BA,OAAhD4C,CAHNA;AAAAA,UAMPG,CAAAA,GAAUH,CAAAA,CAAEvF,UAAFuF,CAAaE,GAAbF,CAAaE,UAAK9C,CAAL8C,EAAK9C;AAAAA,eAAMhB,CAAAA,CAAKgE,yBAALhE,CAA+B4D,CAA/B5D,EAAkCgB,CAAlChB,CAANgB;AAAwCA,OAA1D4C,CANHA;AAQbA,MAAAA,CAAAA,CAAEhJ,QAAFgJ,CAAW5E,CAAX4E,GAAexJ,CAAAA,CAAMiB,WAANjB,CAAkBwJ,CAAAA,CAAEhJ,QAAFgJ,CAAW5E,CAA7B5E,EAAgC,CAAhCA,CAAfwJ,EACAA,CAAAA,CAAEhJ,QAAFgJ,CAAW/E,CAAX+E,GAAexJ,CAAAA,CAAMiB,WAANjB,CAAkBwJ,CAAAA,CAAEhJ,QAAFgJ,CAAW/E,CAA7BzE,EAAgC,CAAhCA,CADfwJ,EAEAA,CAAAA,CAAEhJ,QAAFgJ,CAAWzE,CAAXyE,GAAexJ,CAAAA,CAAMiB,WAANjB,CAAkBwJ,CAAAA,CAAEhJ,QAAFgJ,CAAWzE,CAA7B/E,EAAgC,CAAhCA,CAFfwJ,EAE+C,CAAA,CAEtCtH,IAFsC,CAEtCA;AACP2H,QAAAA,EAAAA,EAAIP,CAAAA,CAAiBC,CAAjBD,EAAwBE,CAAxBF,CADGpH;AACqBsH,QAAAA,UAAAA,EAChBvF,CAFL/B;AAGPgB,QAAAA,SAAAA,EAAWsG,CAAAA,CAAEtG,SAHNhB;AAIP1B,QAAAA,QAAAA,EAAUgJ,CAAAA,CAAEhJ,QAJL0B;AAIK1B,QAAAA,OAAAA,EACHmJ;AALFzH,OAFsC,CAF/CsH;AASWG,KAjBbJ,GAiBaI,CAAAA,CAKRP,MALQO,CAKDzH,IALCyH,CAKIF,CALJE,CAjBbJ;AAsBiBE,GA1BnBL,GA6BOF,CApCwB5F;AAoCxB4F,CA9DLJ,EA8DKI,CAAAA,CAQFD,oBAREC,GAQFD,UAAsB/I,CAAtB+I,EAAsB/I;AAG3B,SAFAF,CAAAA,CAAMC,gBAAND,CAAuBE,CAAvBF,GACAE,CAAAA,CAAS4J,aAAT5J,EADAF,EAEO4F,KAAKmE,0BAALnE,CAAgC1F,CAAhC0F,CAAP;AAAuC1F,CAzErC4I,EAyEqC5I,CAAAA,CAGlCmJ,mBAHkCnJ,GAGlCmJ,UAAqBrG,CAArBqG,EAAqBrG;AAE1ByD,MAEMwD,CAAAA,GAAAA,EAFNxD;AAAAA,MAGIyD,CAAAA,GAAa,CAHjBzD;AAAAA,MAKM0D,CAAAA,GAAgB,UAAUpH,CAAV,EAAUA;AAAAA,IAAAA,CAAAA,CACtBkB,UADsBlB,CACXhB,OADWgB,CACXhB,UAASmC,CAATnC,EAASmC;AAAAA,WACFkG,CADElG,KACtBA,CAAAA,CAAUqF,KADYrF,KAExBA,CAAAA,CAAUqF,KAAVrF,GAAkBnB,CAAAA,CAAQwG,KAA1BrF,EACAiG,CAAAA,CAAcjG,CAAdiG,CAHwBjG;AAGVA,KAJYnB;AAIZmB,GATpBuC;;AASoBvC,SATHlB,CAAAA,CAAegH,QAAfhH,CAcRjB,OAdQiB,CAcRjB,UAASgB,CAAThB,EAASgB;AAAAA,SAEMqH,CAFNrH,KAEZA,CAAAA,CAAQwG,KAFIxG,KAGdA,CAAAA,CAAQwG,KAARxG,GAAgBmH,CAAAA,EAAhBnH,EAEAoH,CAAAA,CAAcpH,CAAdoH,CALcpH,GAQXkH,CAAAA,CAAclH,CAAAA,CAAQwG,KAAtBU,CAAAA,KAA8BA,CAAAA,CAAclH,CAAAA,CAAQwG,KAAtBU,CAAAA,GAAsBV,EAApDU,CARWlH,EAQyCwG,CAAAA,CAE3CxG,CAAAA,CAAQwG,KAFmCA,CAAAA,CAE5BrH,IAF4BqH,CAEvBxG,CAFuBwG,CARzCxG;AAUkBA,GAxBnBC,GA2BViH,CAlBa/F;AAkBb+F,CAzGLnB,EAyGKmB,CAAAA,CAGFI,uBAHEJ,GAGFI,UAAyBtH,CAAzBsH,EAAkCrH,CAAlCqH,EAAkDC,CAAlDD,EAAkDC;AACvD7D,MAAM8D,CAAAA,GAAY,IAAIC,GAAJ,EAAlB/D;AAAAA,MAEMgE,CAAAA,GAASH,CAAAA,CAAiBI,GAAjBJ,CAAqBvH,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CAArBuH,CAFf7D;AAAAA,MAGMkE,CAAAA,GAASL,CAAAA,CAAiBI,GAAjBJ,CAAqBvH,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CAArBuH,CAHf7D;AAAAA,MAIMmE,CAAAA,GAASN,CAAAA,CAAiBI,GAAjBJ,CAAqBvH,CAAAA,CAAQG,SAARH,CAAkB,CAAlBA,CAArBuH,CAJf7D;AASAgE,EAAAA,CAAAA,CAAO1I,OAAP0I,CAAO1I,UAAS8I,CAAT9I,EAAS8I;AAAAA,KACVF,CAAAA,CAAOG,GAAPH,CAAWE,CAAXF,KAAyBC,CAAAA,CAAOE,GAAPF,CAAWC,CAAXD,CADfC,KAC0BA,CAAAA,CAC5BlK,GAD4BkK,CACxB7H,CAAAA,CAAegH,QAAfhH,CAAwB6H,CAAxB7H,CADwB6H,CAD1BA;AAE0BA,GAF1CJ,GAKAE,CAAAA,CAAO5I,OAAP4I,CAAO5I,UAAS8I,CAAT9I,EAAS8I;AACVD,IAAAA,CAAAA,CAAOE,GAAPF,CAAWC,CAAXD,KAAWC,CAAAA,CACHlK,GADGkK,CACC7H,CAAAA,CAAegH,QAAfhH,CAAwB6H,CAAxB7H,CADD6H,CAAXD;AACoCC,GAF1CF,CALAF,EAO0CI,CAAAA,CAIlC5G,UAJkC4G,GAIrBE,KAAAA,CAAMC,IAAND,CAAWR,CAAXQ,CAXrBN;AAWgCF,CAjI9BzB,EAiI8ByB,CAAAA,CAG3BR,0BAH2BQ,GAG3BR,UAA4B7J,CAA5B6J,EAA4B7J;AAWjC,OAAA,IAAA,CAAA,GAAA,IAAA,EATM8J,CAAAA,GAAAA,EASN,EARMpJ,CAAAA,GAAWV,CAAAA,CAASU,QAQ1B,EAPMqK,CAAAA,GAAgB/K,CAAAA,CAAS+K,aAO/B,EADMX,CAAAA,GAAmB,IAAIY,GAAJ,EACzB,EAAS5H,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAI1C,CAAAA,CAASL,MAA7B,EAAqC+C,CAAAA,EAArC,EAAqCA,CAAAA,CAClB6H,GADkB7H,CACdA,CADcA,EACX,IAAIkH,GAAJ,EADWlH;;AACPkH,EAAAA,CAAAA,CAIrBlK,KAJqBkK,CAIfzI,OAJeyI,CAIfzI,UAAS1B,CAAT0B,EAAS1B;AAAAA,IAAAA,CAAAA,CACb6B,IADa7B,CACb6B;AAAAA,MAAAA,EAAAA,EACH2G,CAAAA,EADG3G;AAEPgB,MAAAA,SAAAA,EAAAA,CAAY7C,CAAAA,CAAKQ,CAAjBqC,EAAoB7C,CAAAA,CAAKS,CAAzBoC,EAA4B7C,CAAAA,CAAKU,CAAjCmC,CAFOhB;AAGP1B,MAAAA,QAAAA,EAAUH,CAAAA,CAAKG,QAHR0B;AAIPkJ,MAAAA,MAAAA,EAAQ/K,CAAAA,CAAK+K,MAJNlJ;AAIMkJ,MAAAA,UAAAA,EAAAA;AAJNlJ,KADa7B,GAQtBiK,CAAAA,CAAiBI,GAAjBJ,CAAqBjK,CAAAA,CAAKQ,CAA1ByJ,EAA6B3J,GAA7B2J,CAAiCN,CAAAA,CAASzJ,MAATyJ,GAAkB,CAAnDM,CARsBjK,EAStBiK,CAAAA,CAAiBI,GAAjBJ,CAAqBjK,CAAAA,CAAKS,CAA1BwJ,EAA6B3J,GAA7B2J,CAAiCN,CAAAA,CAASzJ,MAATyJ,GAAkB,CAAnDM,CATsBjK,EAUtBiK,CAAAA,CAAiBI,GAAjBJ,CAAqBjK,CAAAA,CAAKU,CAA1BuJ,EAA6B3J,GAA7B2J,CAAiCN,CAAAA,CAASzJ,MAATyJ,GAAkB,CAAnDM,CAVsBjK;AAU6B,GAdvBmK;AAcuB,MAG/CxH,CAAAA,GAAAA;AAAAA,IAAAA,QAAAA,EACMgH,CADNhH;AACMgH,IAAAA,QAAAA,EACApJ,CAFNoC;AAEMpC,IAAAA,aAAAA,EACKqK;AAHXjI,GAH+C;AAMpCiI,SAIjBjB,CAAAA,CAASjI,OAATiI,CAASjI,UAASgB,CAAThB,EAASgB;AAAAA,IAAAA,CAAAA,CACXsH,uBADWtH,CACaA,CADbA,EACsBC,CADtBD,EACsCuH,CADtCvH;AACsCuH,GADxDN,GAIOhH,CARUiI;AAQVjI,CA5KL8F,EA4KK9F,CAAAA,CAGF4G,yBAHE5G,GAGF4G,UAA2B/I,CAA3B+I,EAA8B9I,CAA9B8I,EAA8B9I;AAEnC2F,MAAM7E,CAAAA,GAAQf,CAAAA,CAAEqC,SAAhBuD;AAAAA,MACM5E,CAAAA,GAAQf,CAAAA,CAAEoC,SADhBuD;AAAAA,MAGM3E,CAAAA,GAAiB,IAAI0I,GAAJ,EAHvB/D;AAWA,MANA7E,CAAAA,CAAMG,OAANH,CAAMG,UAASM,CAATN,EAASM;AACTR,IAAAA,CAAAA,CAAMM,QAANN,CAAeQ,CAAfR,KACFC,CAAAA,CAAenB,GAAfmB,CAAmBO,CAAnBP,CADED;AACiBQ,GAFvBT,GAMIE,CAAAA,CAAe4E,IAAf5E,GAAsB,CAA1B,EAA6B,OAAA,EAAA;AAEzBA,EAAAA,CAAAA,CAAegJ,GAAfhJ,CAAmBF,CAAAA,CAAM,CAANA,CAAnBE,KAAgCA,CAAAA,CAAegJ,GAAfhJ,CAAmBF,CAAAA,CAAMA,CAAAA,CAAMrB,MAANqB,GAAe,CAArBA,CAAnBE,CAAhCA,IAAwE,CAAA,CAEpEI,IAFoE,CAE/DN,CAAAA,CAAMQ,KAANR,EAF+D,CAAxEE,EAKAA,CAAAA,CAAegJ,GAAfhJ,CAAmBD,CAAAA,CAAM,CAANA,CAAnBC,KAAgCA,CAAAA,CAAegJ,GAAfhJ,CAAmBD,CAAAA,CAAMA,CAAAA,CAAMtB,MAANsB,GAAe,CAArBA,CAAnBC,CAAhCA,IAAwE,CAAA,CAEpEI,IAFoE,CAE/DL,CAAAA,CAAMO,KAANP,EAF+D,CALxEC;AAWJ2E,MAAM4E,CAAAA,GAAAA,EAAN5E;AAAM4E,SAENzJ,CAAAA,CAAMG,OAANH,CAAMG,UAASM,CAATN,EAASM;AACTR,IAAAA,CAAAA,CAAMM,QAANN,CAAeQ,CAAfR,KACFwJ,CAAAA,CAAsBnJ,IAAtBmJ,CAA2BhJ,CAA3BgJ,CADExJ;AACyBQ,GAF/BT,GAMOyJ,CARDA;AAQCA,CAjNLvC;;ACFN,IAAMwC,CAAAA,GACJ,YAAA;AACE1F,OAAK+D,OAAL/D,GAAK+D,EAAL/D;AAAK+D,CAFT;;AAESA,CAAAA,CAAAA,SAAAA,CAGPzH,IAHOyH,GAGPzH,UAAMqJ,CAANrJ,EAAUsJ,CAAVtJ,EAAUsJ;AAAAA,OACGpB,CADHoB,KACJA,CADIA,KACcA,CAAAA,GAAKD,CADnBC,GAER5F,KAAK+D,OAAL/D,CAAa1D,IAAb0D,CAAa1D;AAAAA,IAAAA,IAAAA,EACLqJ,CADKrJ;AACLqJ,IAAAA,KAAAA,EACCC;AAFItJ,GAAb0D,CAFQ4F;AAICA,CAPJ7B,EAOI6B,CAAAA,CAAAA,SAAAA,CAIXC,UAJWD,GAIXC,YAAAA;AACEhF,MAGIkF,CAHJlF;AAAAA,MAGgBmF,CAHhBnF;AAAAA,MAG4BoF,CAH5BpF;AAAAA,MAAMkD,CAAAA,GAAU/D,KAAK+D,OAArBlD;AAAAA,MACMiF,CAAAA,GAAAA,EADNjF;AAAAA,MAIIqF,CAAAA,GAAY,CAJhBrF;AAAAA,MAKEsF,CAAAA,GAAY,CALdtF;AAAAA,MAMEuF,CAAAA,GAAa,CANfvF;AAMe,EAAA,CAAA,GAGFkD,CAAAA,CAAQ,CAARA,CAAAA,CAAWsC,IAHT,EAGSA,CAAAA,GACVtC,CAAAA,CAAQ,CAARA,CAAAA,CAAWuC,KAJV,EAOfR,CAAAA,CAAIxJ,IAAJwJ,CAAIxJ,CAAAA,GALSyH,CAAAA,CAAQ,CAARA,CAAAA,CAAWsC,IAKxBP,CAPe;;AASf,OAAKnE,IAAIjE,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIqG,CAAAA,CAAQpJ,MAA5B,EAAoC+C,CAAAA,EAApC,EAAyC;AAAA,QACjC2I,CAAAA,GAAOtC,CAAAA,CAAQrG,CAARqG,CAAAA,CAAWsC,IADe;AAAA,QAEjCC,CAAAA,GAAQvC,CAAAA,CAAQrG,CAARqG,CAAAA,CAAWuC,KAFc;;AAKvC,QAAIlM,CAAAA,CAAM6F,QAAN7F,CAAe2L,CAAf3L,EAA2B6L,CAA3B7L,EAAwCkM,CAAxClM,KAAkD,CAAtD,EAA2D;AAAA,UAAA,EACrDA,CAAAA,CAAM8F,MAAN9F,CAAa2L,CAAb3L,EAAyB6L,CAAzB7L,KAAyCA,CAAAA,CAAM6F,QAAN7F,CAAe2L,CAAf3L,EAA2B4L,CAA3B5L,EAAuCkM,CAAvClM,IAAgD,CADpC,CAAA,EAKlD;AAEL0L,QAAAA,CAAAA,CAAIxJ,IAAJwJ,CAASE,CAATF,GAASE,CAAAA,GAAAA,CAAAA,GAEIA,CAFbF,EAEaE,CAAAA,GAICD,CANdD,EAMcC,CAAAA,GAAAA,CAAAA,GAHFI,CAHZL,EAGYK,CAAAA,GAKCD,CARbJ,EAQaI,CAAAA,GAETA,CAVJJ;AAWA;AAAA;;AAAA,MAAA,CAAA,GAfcQ,CAed,EAfcA,CAAAA,GACD5I,CAcb;AAKJ;;AAAA,QAAItD,CAAAA,CAAM6F,QAAN7F,CAAe2L,CAAf3L,EAA2B4L,CAA3B5L,EAAuCiM,CAAvCjM,KAAgD,CAApD,EAAyD;AAAA,UAAA,EACnDA,CAAAA,CAAM8F,MAAN9F,CAAa2L,CAAb3L,EAAyB4L,CAAzB5L,KAAwCA,CAAAA,CAAM6F,QAAN7F,CAAe2L,CAAf3L,EAA2B6L,CAA3B7L,EAAwCiM,CAAxCjM,IAAgD,CADrC,CAAA,EAKhD;AAEL0L,QAAAA,CAAAA,CAAIxJ,IAAJwJ,CAASG,CAATH,GAASG,CAAAA,GAAAA,CAAAA,GAEIA,CAFbH,EAEaG,CAAAA,GAICF,CANdD,EAMcC,CAAAA,GAAAA,CAAAA,GAHFK,CAHZN,EAGYM,CAAAA,GAKCF,CARbJ,EAQaI,CAAAA,GAETA,CAVJJ;AAWA;AAAA;;AAAA,MAAA,CAAA,GAfaO,CAeb,EAfaA,CAAAA,GACD3I,CAcZ;AAdYA;AAAAA;;AAAAA,SAmBE,MAAfoI,CAAAA,CAAInL,MAAW,IAAQP,CAAAA,CAAM8F,MAAN9F,CAAa0L,CAAAA,CAAIA,CAAAA,CAAInL,MAAJmL,GAAa,CAAjBA,CAAb1L,EAAkC2J,CAAAA,CAAQA,CAAAA,CAAQpJ,MAARoJ,GAAiB,CAAzBA,CAAAA,CAA4BsC,IAA9DjM,CAAR,IAElB0L,CAAAA,CAAIxJ,IAAJwJ,CAAS/B,CAAAA,CAAQA,CAAAA,CAAQpJ,MAARoJ,GAAiB,CAAzBA,CAAAA,CAA4BsC,IAArCP,CAFkB,EAKpB9F,KAAKuG,IAALvG,GAAY8F,CALQ,EAMbA,CAzBWpI;AAyBXoI,CApFF/B;;AAoFE+B,ICqGN6B,CDrGM7B;AAAAA,ICuGN8B,CDvGM9B;AAAAA,ICiGJ2C,CDjGI3C;AAAAA,ICkGJ4C,CDlGI5C;AAAAA,ICmGJ8C,CDnGI9C;AAAAA,ICsGNgD,CDtGMhD;AAAAA,IC9ELU,CAAAA,GACL,YAAA;AACCxG,OAAKyG,KAALzG,GAAKyG,EAALzG;AAAKyG,CD4EIX;;AC5EJW,CAAAA,CAQCC,UARDD,GAQCC,UAAYpM,CAAZoM,EAAYpM;AAClB,SAAO4I,CAAAA,CAAQC,SAARD,CAAkB5I,CAAlB4I,CAAP;AAAyB5I,CATpBmM,EASoBnM,CAAAA,CAAAA,SAAAA,CAQ1BqM,WAR0BrM,GAQ1BqM,UAAaC,CAAbD,EAAqBrD,CAArBqD,EAAqBrD;AAAAA,OACfmD,KADenD,CACTsD,CADStD,IACCA,CADDA;AACCA,CAlBhBmD,EAkBgBnD,CAAAA,CAAAA,SAAAA,CAStBuD,QATsBvD,GAStBuD,UAAUD,CAAVC,EAAkBC,CAAlBD,EAAkBC;AACjB,MAAA,CAAK9G,KAAKyG,KAALzG,CAAW4G,CAAX5G,CAAL,EAAyB,OAAO,IAAP;AAEzB2B,MAAIoF,CAAAA,GAAmB,IAAvBpF;AAAAA,MACIqF,CAAAA,GAAWpL,IAAAA,CAAKqL,GAALrL,CAAS,EAATA,EAAa,CAAbA,CADf+F;AAC4B,SAE5B3B,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBwD,MAAnBxD,CAA0B7D,OAA1B6D,CAA0B7D,UAASwH,CAATxH,EAAgB+K,CAAhB/K,EAAgB+K;AACzCvD,IAAAA,CAAAA,CAAMxH,OAANwH,CAAMxH,UAASyE,CAATzE,EAASyE;AACdC,UAAMsG,CAAAA,GAAmB/M,CAAAA,CAAM0E,iBAAN1E,CAAwBwG,CAAAA,CAAKhG,QAA7BR,EAAuC0M,CAAvC1M,CAAzByG;AACIsG,MAAAA,CAAAA,GAAmBH,CAAnBG,KAAmBH,CAAAA,GACHE,CADGF,EACHE,CAAAA,GACRC,CAFRA;AAEQA,KAJbxD;AAIawD,GALdnH,GAUO+G,CAZqB;AAYrBA,CA3CFN,EA2CEM,CAAAA,CAAAA,SAAAA,CAWRK,aAXQL,GAWRK,UAAeR,CAAfQ,EAAuBC,CAAvBD,EAAgCE,CAAhCF,EAA8CG,CAA9CH,EAA8CG;AAE7C,MAAA,CAAKvH,KAAKyG,KAALzG,CAAW4G,CAAX5G,CAAL,EAAyB,OAAO,IAAInF,KAAAA,CAAMC,OAAV,EAAP;AAEzBwM,EAAAA,CAAAA,GAAeA,CAAAA,IAAgB,IAA/BA,EACAC,CAAAA,GAAYA,CAAAA,IAAa,CADzBD;AAGAzG,MAAM2G,CAAAA,GAAAA,EAAN3G;AAaA,SAZiBb,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBwD,MAAnBxD,CAA0BqH,CAA1BrH,EAER7D,OAFQ6D,CAER7D,UAASyH,CAATzH,EAASyH;AACb0D,IAAAA,CAAAA,IAAgBC,CAAhBD,GACClN,CAAAA,CAAM0E,iBAAN1E,CAAwBkN,CAAxBlN,EAAsCwJ,CAAAA,CAAEhJ,QAAxCR,IAAoDmN,CAAAA,GAAYA,CAAhEnN,IAAgEmN,CAAAA,CACxDjL,IADwDiL,CACnD3D,CAAAA,CAAEhJ,QADiD2M,CADjED,GAEgB1M,CAAAA,CAGR0B,IAHQ1B,CAGHgJ,CAAAA,CAAEhJ,QAHCA,CAFhB0M;AAKe1M,GARHoF,GAYV5F,CAAAA,CAAMsB,MAANtB,CAAaoN,CAAbpN,KAA4B,IAAIS,KAAAA,CAAMC,OAAV,EAAnC;AAA6CA,CA1ExC2L,EA0EwC3L,CAAAA,CAAAA,SAAAA,CAW9C2M,cAX8C3M,GAW9C2M,UAAgBX,CAAhBW,EAA0Bb,CAA1Ba,EAAkCJ,CAAlCI,EAA2CC,CAA3CD,EAA2CC;AAAAA,OAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAe,CAAfA;AAC1C7G,MACM7F,CAAAA,GAAWgF,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBhF,QADpC6F;AAAAA,MAEI8G,CAAAA,GAAc,IAFlB9G;AAAAA,MAGI+G,CAAAA,GAAkBC,QAHtBhH;AAGsBgH,SAHR7H,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBwD,MAAnBxD,CAA0BqH,CAA1BrH,EAKR7D,OALQ6D,CAKR7D,UAASyE,CAATzE,EAASyE;AACdC,QAAMmG,CAAAA,GAAW5M,CAAAA,CAAM0E,iBAAN1E,CAAwBwG,CAAAA,CAAKhG,QAA7BR,EAAuC0M,CAAvC1M,CAAjByG;AACImG,IAAAA,CAAAA,GAAWY,CAAXZ,KAAWY,CACRF,CADQE,IACQxN,CAAAA,CAAMqF,iBAANrF,CAAwB0M,CAAxB1M,EAAkCwG,CAAlCxG,EAAwCY,CAAxCZ,CADnB4M,MAC2DhM,CAAAA,GAChD4F,CADgD5F,EAChD4F,CAAAA,GACIoG,CAHfA;AAGeA,GAVNhH,GAcP2H,CAXeE;AAWfF,CApGFlB,EAoGEkB,CAAAA,CAAAA,SAAAA,CAaRG,QAbQH,GAaRG,UAAUC,CAAVD,EAAyBE,CAAzBF,EAAyClB,CAAzCkB,EAAiDT,CAAjDS,EAAiDT;AAChDxG,MAAMoH,CAAAA,GAAQjI,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBwD,MAAnBxD,CAA0BqH,CAA1BrH,CAAda;AAAAA,MACM7F,CAAAA,GAAWgF,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBhF,QADpC6F;AAAAA,MAGM8G,CAAAA,GAAc3H,KAAKyH,cAALzH,CAAoB+H,CAApB/H,EAAmC4G,CAAnC5G,EAA2CqH,CAA3CrH,CAHpBa;AAAAA,MAIMqH,CAAAA,GAAelI,KAAKyH,cAALzH,CAAoBgI,CAApBhI,EAAoC4G,CAApC5G,EAA4CqH,CAA5CrH,EAA4CqH,CAAS,CAArDrH,CAJrBa;AAOA,MAAA,CAAK8G,CAAL,IAAKA,CAAgBO,CAArB,EAAqBA,OACb,IADaA;;AAIrBrH,MAAMsH,CAAAA,GAAQ3G,CAAAA,CAAMW,MAANX,CAAayG,CAAbzG,EAAoBmG,CAApBnG,EAAiC0G,CAAjC1G,CAAdX;AAAAA,MAEMuH,CAAAA,GAAkB,UAAUnN,CAAV,EAAaC,CAAb,EAAaA;AACpC,SAAK,IAAIwC,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIzC,CAAAA,CAAEoD,UAAFpD,CAAaN,MAAjC,EAAyC+C,CAAAA,EAAzC,EAAyCA,IACpCzC,CAAAA,CAAEoD,UAAFpD,CAAayC,CAAbzC,MAAoBC,CAAAA,CAAE+I,EADcvG,EAEvC,OAAOzC,CAAAA,CAAE8I,OAAF9I,CAAUyC,CAAVzC,CAAP;AAAiByC,GALpBmD;AAAAA,MAWMwH,CAAAA,GAAU,IAAI3C,CAAJ,EAXhB7E;;AAYAwH,EAAAA,CAAAA,CAAQ/L,IAAR+L,CAAaN,CAAbM;;AACA,OAAK1G,IAAIjE,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIyK,CAAAA,CAAMxN,MAA1B,EAAkC+C,CAAAA,EAAlC,EAAuC;AAAA,QAEhC4K,CAAAA,GAAcH,CAAAA,CAAMzK,CAAAA,GAAI,CAAVyK,CAFkB;;AAER,QAE1BG,CAF0B,EAEb;AAAA,UACVvE,CAAAA,GAAUqE,CAAAA,CAJDD,CAAAA,CAAMzK,CAANyK,CAICC,EAAyBE,CAAzBF,CADA;AACyBE,MAAAA,CAAAA,CACjChM,IADiCgM,CAExCtN,CAAAA,CAAS+I,CAAAA,CAAQ,CAARA,CAAT/I,CAFwCsN,EAGxCtN,CAAAA,CAAS+I,CAAAA,CAAQ,CAARA,CAAT/I,CAHwCsN;AAGvB;AAIpBD;;AAAAA,EAAAA,CAAAA,CAAQ/L,IAAR+L,CAAaL,CAAbK,GACAA,CAAAA,CAAQxC,UAARwC,EADAA;AAIAxH,MAAM0F,CAAAA,GAAO8B,CAAAA,CAAQ9B,IAAR8B,CAAavE,GAAbuE,CAAavE,UAAK3I,CAAL2I,EAAK3I;AAAAA,WAAM,IAAIN,KAAAA,CAAMC,OAAV,CAAkBK,CAAAA,CAAE6D,CAApB,EAAuB7D,CAAAA,CAAE0D,CAAzB,EAA4B1D,CAAAA,CAAEgE,CAA9B,CAANhE;AAAoCgE,GAAtDkJ,CAAbxH;AAAmE1B,SACnEoH,CAAAA,CAAK/J,KAAL+J,IACOA,CAF4DpH;AAE5DoH,CA5JFE,EA4KPD,CAAAA,CAAY+B,SAAZ/B,CAAsBgC,SAAtBhC,IACOiC,CAAAA,GAAQ,IAAI5N,KAAAA,CAAMC,OAAV,EAAR2N,EACAC,CAAAA,GAAQ,IAAI7N,KAAAA,CAAM8N,KAAV,EADRF,EAEAG,CAAAA,GAAW,IAAI/N,KAAAA,CAAMgO,QAAV,EAFXJ,EAKFK,CAAAA,GAAe,IAAIjO,KAAAA,CAAMC,OAAV,EALb2N,EAQC,UAAUrG,CAAV,EAAiB3B,CAAjB,EAAsBG,CAAtB,EAA4BgG,CAA5B,EAAoCS,CAApC,EAA6C0B,CAA7C,EAA6CA;AACnDlI,MAAM7F,CAAAA,GAAWgF,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBhF,QAApC6F;AAAAA,MACMoH,CAAAA,GAAQjI,KAAKyG,KAALzG,CAAW4G,CAAX5G,EAAmBwD,MAAnBxD,CAA0BqH,CAA1BrH,CADda;AAAAA,MAGMmI,CAAAA,GAAAA,CAAapI,CAAboI,CAHNnI;AAAAA,MAIMoI,CAAAA,GAAAA,EAJNpI;AAKAoI,EAAAA,CAAAA,CAAUrI,CAAAA,CAAKqD,EAAfgF,CAAAA,GAAqB,CAArBA,EAEAtB,CAAAA,GAAAA,KAAcnD,CAFdyE,EAGAH,CAAAA,CAAavD,GAAbuD,CAAiB,CAAjBA,EAAoB,CAApBA,EAAuB,CAAvBA,CAHAG,EAIArB,CAAAA,GAAkBC,QAJlBoB,EAOAP,CAAAA,CAAMQ,qBAANR,CACC1N,CAAAA,CAAS4F,CAAAA,CAAKtD,SAALsD,CAAe,CAAfA,CAAT5F,CADD0N,EAEC1N,CAAAA,CAAS4F,CAAAA,CAAKtD,SAALsD,CAAe,CAAfA,CAAT5F,CAFD0N,EAGC1N,CAAAA,CAAS4F,CAAAA,CAAKtD,SAALsD,CAAe,CAAfA,CAAT5F,CAHD0N,CAPAO,EAYAP,CAAAA,CAAMS,YAANT,CAAmBjI,CAAnBiI,EAAwBD,CAAxBC,CAZAO,EAaAxI,CAAAA,CAAIlD,IAAJkD,CAASgI,CAAThI,CAbAwI;;AAeA,OAAKtH,IAAIW,CAAAA,GAAc0G,CAAAA,CAAUhM,GAAVgM,EAAvB,EAAwC1G,CAAxC,EAAqDA,CAAAA,GAAc0G,CAAAA,CAAUhM,GAAVgM,EAAnE,EAAoF;AAEnFJ,IAAAA,CAAAA,CAASrD,GAATqD,CACC5N,CAAAA,CAASsH,CAAAA,CAAYhF,SAAZgF,CAAsB,CAAtBA,CAATtH,CADD4N,EAEC5N,CAAAA,CAASsH,CAAAA,CAAYhF,SAAZgF,CAAsB,CAAtBA,CAATtH,CAFD4N,EAGC5N,CAAAA,CAASsH,CAAAA,CAAYhF,SAAZgF,CAAsB,CAAtBA,CAATtH,CAHD4N,GAMAA,CAAAA,CAASQ,mBAATR,CAA6BnI,CAA7BmI,EAAkCH,CAAlCG,CANAA,EAQIH,CAAAA,CAAM3J,iBAAN2J,CAAwBhI,CAAxBgI,IAA+Bb,CAA/Ba,KACHd,CAAAA,GAAcrF,CAAdqF,EACAmB,CAAAA,CAAavL,IAAbuL,CAAkBL,CAAlBK,CADAnB,EAEAC,CAAAA,GAAkBa,CAAAA,CAAM3J,iBAAN2J,CAAwBhI,CAAxBgI,CAHfA,CARJG;AAcA/H,QAAMwI,CAAAA,GAAQJ,CAAAA,CAAU3G,CAAV2G,CAAdpI;AACA,QAAA,EAAIwI,CAAAA,GAAQ,CAAZ,CAAA,EAEA,KAAK1H,IAAIjE,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAI4E,CAAAA,CAAYjE,UAAZiE,CAAuB3H,MAA3C,EAAmD+C,CAAAA,EAAnD,EAAwD;AACvDmD,UAAMvC,CAAAA,GAAY2J,CAAAA,CAAM3F,CAAAA,CAAYjE,UAAZiE,CAAuB5E,CAAvB4E,CAAN2F,CAAlBpH;AACIvC,MAAAA,CAAAA,CAAU2F,EAAV3F,IAAgB2K,CAAhB3K,KAEJ0K,CAAAA,CAAU1M,IAAV0M,CAAe1K,CAAf0K,GACAC,CAAAA,CAAU3K,CAAAA,CAAU2F,EAApBgF,CAAAA,GAA0BI,CAAAA,GAAQ,CAH9B/K;AAG8B;AAKpC;;AAAA,SADAyK,CAAAA,CAAUxL,IAAVwL,CAAeD,CAAfC,GACOpB,CAAP;AAAOA,CA3DTnB,CA5KOC;AAuOEkB,SAAAA,CAAAA,IAAAA,WAAAA","sourcesContent":["class Utils {\n\n  static computeCentroids (geometry) {\n    var f, fl, face;\n\n    for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n      face = geometry.faces[ f ];\n      face.centroid = new THREE.Vector3( 0, 0, 0 );\n\n      face.centroid.add( geometry.vertices[ face.a ] );\n      face.centroid.add( geometry.vertices[ face.b ] );\n      face.centroid.add( geometry.vertices[ face.c ] );\n      face.centroid.divideScalar( 3 );\n\n    }\n  }\n\n  static roundNumber (value, decimals) {\n    return Number(value.toFixed(decimals));\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static mergeVertexIds (aList, bList) {\n\n    var sharedVertices = [];\n\n    aList.forEach((vID) => {\n      if (bList.indexOf(vID) >= 0) {\n        sharedVertices.push(vID);\n      }\n    });\n\n    if (sharedVertices.length < 2) return [];\n\n    if (sharedVertices.includes(aList[0]) && sharedVertices.includes(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.includes(bList[0]) && sharedVertices.includes(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    sharedVertices = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.push(vId);\n      }\n    });\n\n    var clockwiseMostSharedVertex = sharedVertices[1];\n    var counterClockwiseMostSharedVertex = sharedVertices[0];\n\n\n    var cList = aList.slice();\n    while (cList[0] !== clockwiseMostSharedVertex) {\n      cList.push(cList.shift());\n    }\n\n    var c = 0;\n\n    var temp = bList.slice();\n    while (temp[0] !== counterClockwiseMostSharedVertex) {\n      temp.push(temp.shift());\n\n      if (c++ > 10) throw new Error('Unexpected state');\n    }\n\n    // Shave\n    temp.shift();\n    temp.pop();\n\n    cList = cList.concat(temp);\n\n    return cList;\n  }\n\n  static setPolygonCentroid (polygon, navigationMesh) {\n    var sum = new THREE.Vector3();\n\n    var vertices = navigationMesh.vertices;\n\n    polygon.vertexIds.forEach((vId) => {\n      sum.add(vertices[vId]);\n    });\n\n    sum.divideScalar(polygon.vertexIds.length);\n\n    polygon.centroid.copy(sum);\n  }\n\n  static cleanPolygon (polygon, navigationMesh) {\n\n    var newVertexIds = [];\n\n    var vertices = navigationMesh.vertices;\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertexId, previousVertexId;\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertexId = polygon.vertexIds[1];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 1];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertexId = polygon.vertexIds[0];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 2];\n      } else {\n        nextVertexId = polygon.vertexIds[i + 1];\n        previousVertexId = polygon.vertexIds[i - 1];\n      }\n\n      nextVertex = vertices[nextVertexId];\n      previousVertex = vertices[previousVertexId];\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n\n      if (angle > Math.PI - 0.01 && angle < Math.PI + 0.01) {\n\n        // Remove the neighbours who had this vertex\n        var goodNeighbours = [];\n        polygon.neighbours.forEach((neighbour) => {\n          if (!neighbour.vertexIds.includes(polygon.vertexIds[i])) {\n            goodNeighbours.push(neighbour);\n          }\n        });\n        polygon.neighbours = goodNeighbours;\n\n\n        // TODO cleanup the list of vertices and rebuild vertexIds for all polygons\n      } else {\n        newVertexIds.push(polygon.vertexIds[i]);\n      }\n\n    }\n\n    polygon.vertexIds = newVertexIds;\n\n    this.setPolygonCentroid(polygon, navigationMesh);\n\n  }\n\n  static isConvex (polygon, navigationMesh) {\n\n    var vertices = navigationMesh.vertices;\n\n    if (polygon.vertexIds.length < 3) return false;\n\n    var convex = true;\n\n    var total = 0;\n\n    var results = [];\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertex = vertices[polygon.vertexIds[1]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 1]];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertex = vertices[polygon.vertexIds[0]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 2]];\n      } else {\n        nextVertex = vertices[polygon.vertexIds[i + 1]];\n        previousVertex = vertices[polygon.vertexIds[i - 1]];\n      }\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n      total += angle;\n\n      if (angle === Math.PI || angle === 0) return false;\n\n      var r = a.cross(b).y;\n      results.push(r);\n    }\n\n    // if ( total > (polygon.vertexIds.length-2)*Math.PI ) return false;\n\n    results.forEach((r) => {\n      if (r === 0) convex = false;\n    });\n\n    if (results[0] > 0) {\n      results.forEach((r) => {\n        if (r < 0) convex = false;\n      });\n    } else {\n      results.forEach((r) => {\n        if (r > 0) convex = false;\n      });\n    }\n\n    return convex;\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n}\n\nexport { Utils };\n","// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n","import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + neighbour.cost;\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    return Utils.distanceToSquared(pos1, pos2);\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n","import { Utils } from './Utils';\n\nlet polygonId = 1;\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {THREE.Geometry} geometry\n   * @return {Zone}\n   */\n  static buildZone (geometry) {\n\n    const navMesh = this._buildNavigationMesh(geometry);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    zone.groups = [];\n\n    const findPolygonIndex = function (group, p) {\n      for (let i = 0; i < group.length; i++) {\n        if (p === group[i]) return i;\n      }\n    };\n\n    // TODO: This block represents 50-60% of navigation mesh construction time,\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    groups.forEach((group) => {\n\n      const newGroup = [];\n\n      group.forEach((p) => {\n\n        // TODO: Optimize.\n        const neighbours = p.neighbours.map((n) => findPolygonIndex(group, n));\n\n        // Build a portal list to each neighbour\n        const portals = p.neighbours.map((n) => this._getSharedVerticesInOrder(p, n));\n\n        p.centroid.x = Utils.roundNumber(p.centroid.x, 2);\n        p.centroid.y = Utils.roundNumber(p.centroid.y, 2);\n        p.centroid.z = Utils.roundNumber(p.centroid.z, 2);\n\n        newGroup.push({\n          id: findPolygonIndex(group, p),\n          neighbours: neighbours,\n          vertexIds: p.vertexIds,\n          centroid: p.centroid,\n          portals: portals\n        });\n\n      });\n\n      zone.groups.push(newGroup);\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {THREE.Geometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry) {\n    Utils.computeCentroids(geometry);\n    geometry.mergeVertices();\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n    let groupCount = 0;\n\n    const spreadGroupId = function (polygon) {\n      polygon.neighbours.forEach((neighbour) => {\n        if (neighbour.group === undefined) {\n          neighbour.group = polygon.group;\n          spreadGroupId(neighbour);\n        }\n      });\n    };\n\n    polygons.forEach((polygon) => {\n\n      if (polygon.group === undefined) {\n        polygon.group = groupCount++;\n        // Spread it\n        spreadGroupId(polygon);\n      }\n\n      if (!polygonGroups[polygon.group]) polygonGroups[polygon.group] = [];\n\n      polygonGroups[polygon.group].push(polygon);\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, navigationMesh, vertexPolygonMap) {\n    const neighbors = new Set();\n\n    const groupA = vertexPolygonMap.get(polygon.vertexIds[0]);\n    const groupB = vertexPolygonMap.get(polygon.vertexIds[1]);\n    const groupC = vertexPolygonMap.get(polygon.vertexIds[2]);\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bubl cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (groupB.has(candidate) || groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n\n    polygon.neighbours = Array.from(neighbors);\n  }\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n\n    // Constructing the neighbor graph brute force is O(n). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n    const vertexPolygonMap = new Map(); // Map<vertexID, Set<polygonIndex>>\n    for (let i = 0; i < vertices.length; i++) {\n      vertexPolygonMap.set(i, new Set());\n    }\n\n    // Convert the faces into a custom format that supports more than 3 vertices\n    geometry.faces.forEach((face) => {\n      polygons.push({\n        id: polygonId++,\n        vertexIds: [face.a, face.b, face.c],\n        centroid: face.centroid,\n        normal: face.normal,\n        neighbours: []\n      });\n      vertexPolygonMap.get(face.a).add(polygons.length - 1);\n      vertexPolygonMap.get(face.b).add(polygons.length - 1);\n      vertexPolygonMap.get(face.c).add(polygons.length - 1);\n    });\n\n    const navigationMesh = {\n      polygons: polygons,\n      vertices: vertices,\n      faceVertexUvs: faceVertexUvs\n    };\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      this._buildPolygonNeighbours(polygon, navigationMesh, vertexPolygonMap);\n    });\n\n    return navigationMesh;\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const bList = b.vertexIds;\n\n    const sharedVertices = new Set();\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.add(vId);\n      }\n    });\n\n    if (sharedVertices.size < 2) return [];\n\n    if (sharedVertices.has(aList[0]) && sharedVertices.has(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.has(bList[0]) && sharedVertices.has(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    const sharedVerticesOrdered = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVerticesOrdered.push(vId);\n      }\n    });\n\n    return sharedVerticesOrdered;\n  }\n}\n\nexport { Builder };\n","import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n","/* global THREE */\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {THREE.Geometry} geometry\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry) {\n\t\treturn Builder.buildZone(geometry);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns closest node group ID for given position.\n\t * @param  {string} zoneID\n\t * @param  {THREE.Vector3} position\n\t * @return {number}\n\t */\n\tgetGroup (zoneID, position) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\n\t\tthis.zones[zoneID].groups.forEach((group, index) => {\n\t\t\tgroup.forEach((node) => {\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = index;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn closestNodeGroup;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {THREE.Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new THREE.Vector3();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new THREE.Vector3();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {THREE.Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {THREE.Vector3} startPosition Start position.\n\t * @param  {THREE.Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<THREE.Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new THREE.Vector3(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {THREE.Vector3} start\n * @param  {THREE.Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {THREE.Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\nPathfinding.prototype.clampStep = (function () {\n\tconst point = new THREE.Vector3();\n\tconst plane = new THREE.Plane();\n\tconst triangle = new THREE.Triangle();\n\n\tlet closestNode;\n\tlet closestPoint = new THREE.Vector3();\n\tlet closestDistance;\n\n\treturn function (start, end, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(end, point);\n\t\tend.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(end, point);\n\n\t\t\tif (point.distanceToSquared(end) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(end);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<THREE.Vector3} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number} vertexIds\n * @property {THREE.Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n"]},"metadata":{},"sourceType":"module"}