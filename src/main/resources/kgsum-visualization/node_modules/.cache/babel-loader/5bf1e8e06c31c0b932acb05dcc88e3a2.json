{"ast":null,"code":"/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {\n      default: ''\n    },\n    state: {\n      default: 'collided'\n    },\n    radius: {\n      default: 0.05\n    },\n    watch: {\n      default: true\n    }\n  },\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n\n    this.collisions = [];\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n  remove: function () {\n    this.pause();\n  },\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {\n        childList: true,\n        subtree: true\n      });\n    }\n  },\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls; // Push entities into list of els to intersect.\n\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    } // Convert from NodeList to Array\n\n\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n  tick: function () {\n    const position = new THREE.Vector3(),\n          meshPosition = new THREE.Vector3(),\n          colliderScale = new THREE.Vector3(),\n          size = new THREE.Vector3(),\n          box = new THREE.Box3(),\n          distanceMap = new Map();\n    return function () {\n      const el = this.el,\n            data = this.data,\n            mesh = el.getObject3D('mesh'),\n            collisions = [];\n      let colliderRadius;\n\n      if (!mesh) {\n        return;\n      }\n\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale); // Update collision list.\n\n      this.els.forEach(intersect); // Emit events and add collision states, in order of distance.\n\n      collisions.sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1).forEach(this.handleHit); // Remove collision state from current element.\n\n      if (collisions.length === 0) {\n        el.emit('hit', {\n          el: null\n        });\n      } // Remove collision state from other elements.\n\n\n      this.collisions.filter(el => !distanceMap.has(el)).forEach(this.handleHitEnd); // Store new collisions\n\n      this.collisions = collisions; // Bounding sphere collision detection\n\n      function intersect(el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) {\n          return;\n        }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) {\n          return;\n        }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) {\n          return;\n        }\n\n        distance = position.distanceTo(meshPosition);\n\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      } // use max of scale factors to maintain bounding sphere collision\n\n\n      function scaleFactor(scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  }(),\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {\n      el: targetEl\n    });\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {\n      el: targetEl\n    });\n  }\n});","map":{"version":3,"sources":["E:/Universitat Paderborn/NEW/src/node_modules/aframe-extras/src/misc/sphere-collider.js"],"names":["module","exports","AFRAME","registerComponent","schema","objects","default","state","radius","watch","init","observer","els","collisions","handleHit","bind","handleHitEnd","remove","pause","play","sceneEl","el","data","MutationObserver","update","observe","childList","subtree","disconnect","objectEls","querySelectorAll","children","Array","prototype","slice","call","tick","position","THREE","Vector3","meshPosition","colliderScale","size","box","Box3","distanceMap","Map","mesh","getObject3D","colliderRadius","clear","object3D","getWorldPosition","getWorldScale","scaleFactor","forEach","intersect","sort","a","b","get","length","emit","filter","has","distance","extent","isEntity","setFromObject","getSize","Math","max","x","y","z","sqrt","getCenter","distanceTo","push","set","scaleVec","apply","toArray","targetEl","addState","removeState"],"mappings":"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","sourcesContent":["/**\n * Based on aframe/examples/showcase/tracked-controls.\n *\n * Implement bounding sphere collision detection for entities with a mesh.\n * Sets the specified state on the intersected entities.\n *\n * @property {string} objects - Selector of the entities to test for collision.\n * @property {string} state - State to set on collided entities.\n *\n */\nmodule.exports = AFRAME.registerComponent('sphere-collider', {\n  schema: {\n    objects: {default: ''},\n    state: {default: 'collided'},\n    radius: {default: 0.05},\n    watch: {default: true}\n  },\n\n  init: function () {\n    /** @type {MutationObserver} */\n    this.observer = null;\n    /** @type {Array<Element>} Elements to watch for collisions. */\n    this.els = [];\n    /** @type {Array<Element>} Elements currently in collision state. */\n    this.collisions = [];\n\n    this.handleHit = this.handleHit.bind(this);\n    this.handleHitEnd = this.handleHitEnd.bind(this);\n  },\n\n  remove: function () {\n    this.pause();\n  },\n\n  play: function () {\n    const sceneEl = this.el.sceneEl;\n\n    if (this.data.watch) {\n      this.observer = new MutationObserver(this.update.bind(this, null));\n      this.observer.observe(sceneEl, {childList: true, subtree: true});\n    }\n  },\n\n  pause: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  },\n\n  /**\n   * Update list of entities to test for collision.\n   */\n  update: function () {\n    const data = this.data;\n    let objectEls;\n\n    // Push entities into list of els to intersect.\n    if (data.objects) {\n      objectEls = this.el.sceneEl.querySelectorAll(data.objects);\n    } else {\n      // If objects not defined, intersect with everything.\n      objectEls = this.el.sceneEl.children;\n    }\n    // Convert from NodeList to Array\n    this.els = Array.prototype.slice.call(objectEls);\n  },\n\n  tick: (function () {\n    const position = new THREE.Vector3(),\n        meshPosition = new THREE.Vector3(),\n        colliderScale = new THREE.Vector3(),\n        size = new THREE.Vector3(),\n        box = new THREE.Box3(),\n        distanceMap = new Map();\n    return function () {\n      const el = this.el,\n          data = this.data,\n          mesh = el.getObject3D('mesh'),\n          collisions = [];\n      let colliderRadius;\n\n      if (!mesh) { return; }\n\n      distanceMap.clear();\n      el.object3D.getWorldPosition(position);\n      el.object3D.getWorldScale(colliderScale);\n      colliderRadius = data.radius * scaleFactor(colliderScale);\n      // Update collision list.\n      this.els.forEach(intersect);\n\n      // Emit events and add collision states, in order of distance.\n      collisions\n        .sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1)\n        .forEach(this.handleHit);\n\n      // Remove collision state from current element.\n      if (collisions.length === 0) { el.emit('hit', {el: null}); }\n\n      // Remove collision state from other elements.\n      this.collisions\n        .filter((el) => !distanceMap.has(el))\n        .forEach(this.handleHitEnd);\n\n      // Store new collisions\n      this.collisions = collisions;\n\n      // Bounding sphere collision detection\n      function intersect (el) {\n        let radius, mesh, distance, extent;\n\n        if (!el.isEntity) { return; }\n\n        mesh = el.getObject3D('mesh');\n\n        if (!mesh) { return; }\n\n        box.setFromObject(mesh).getSize(size);\n        extent = Math.max(size.x, size.y, size.z) / 2;\n        radius = Math.sqrt(2 * extent * extent);\n        box.getCenter(meshPosition);\n\n        if (!radius) { return; }\n\n        distance = position.distanceTo(meshPosition);\n        if (distance < radius + colliderRadius) {\n          collisions.push(el);\n          distanceMap.set(el, distance);\n        }\n      }\n      // use max of scale factors to maintain bounding sphere collision\n      function scaleFactor (scaleVec) {\n        return Math.max.apply(null, scaleVec.toArray());\n      }\n    };\n  })(),\n\n  handleHit: function (targetEl) {\n    targetEl.emit('hit');\n    targetEl.addState(this.data.state);\n    this.el.emit('hit', {el: targetEl});\n  },\n  handleHitEnd: function (targetEl) {\n    targetEl.emit('hitend');\n    targetEl.removeState(this.data.state);\n    this.el.emit('hitend', {el: targetEl});\n  }\n});\n"]},"metadata":{},"sourceType":"script"}